{
  "version": 4,
  "stack": "go",
  "stackLabel": "Go",
  "ciSystems": ["azure-devops"],
  "meta": {
    "defaultCoverageThreshold": 0.8,
    "coverageThresholdUnit": "ratio",
    "coverageThresholdDescription": "Expressed as a ratio (0-1), e.g., 0.8 = 80% coverage. Must be between 0 and 1.",
    "complexityChecks": {
      "enabledByDefault": true,
      "description": "When supported by the stack, run cyclomatic complexity or similar metrics in CI as a warning-only check initially."
    },
    "qualityGatePolicy": {
      "preferSoftFailOnLegacy": true,
      "description": "New quality checks should warn on existing code and fail CI only for violations introduced in new or changed code, to reduce friction on legacy codebases."
    },
    "migrationGuide": [
      {
        "step": 0,
        "title": "Foundation: Line Endings and Hook Entry Point",
        "description": "Configure .gitattributes for cross-platform line ending correctness and establish the canonical verify entrypoint before adding any checks. This prevents 'works locally, fails in CI' issues from day one.",
        "focusIds": [
          "gitattributes-eol",
          "canonical-verify",
          "hook-ci-parity",
          "config-authority"
        ],
        "notes": "Start here to avoid debugging cryptic CRLF failures later. Use .gitattributes as the authority for EOL (not .editorconfig). Run 'git add --renormalize .' after adding .gitattributes to fix existing files."
      },
      {
        "step": 1,
        "title": "Establish Local Safety Nets First",
        "description": "Add pre-commit hooks with secret scanning, formatting, and linting. Hooks should CHECK (not auto-fix) and scope to changed files only for speed.",
        "focusIds": [
          "pre-commit-hooks",
          "secret-scanning-precommit",
          "linting",
          "code-formatter"
        ],
        "notes": "Keep hooks fast by scoping to staged files. Use Husky as entry point calling lint-staged or pre-commit. Hooks should check, not fix, to keep developers aware of issues."
      },
      {
        "step": 2,
        "title": "Mirror Local Checks in CI with CRLF Detection",
        "description": "Introduce CI quality gates that mirror local hooks exactly. Add CRLF detection early in pipeline. Treat existing violations as warnings where possible.",
        "focusIds": [
          "crlf-detection",
          "ci-quality-gates",
          "linting",
          "code-formatter",
          "commit-linting"
        ],
        "notes": "CI must call the same verify scripts that hooks use. Add CRLF detection before other checks to fail fast on line ending issues. Use diff-based tools so only new violations break builds."
      },
      {
        "step": 3,
        "title": "Add Type Safety, Coverage, and Dependency Security",
        "description": "Enable type-checking, coverage thresholds, and dependency/vulnerability scanning with gradual enforcement.",
        "focusIds": [
          "type-checking",
          "unit-test-runner",
          "unit-test-reporter",
          "dependency-security",
          "dependency-update-automation"
        ],
        "notes": "Pin tool and runtime versions in CI and containers to avoid flaky differences across environments."
      },
      {
        "step": 4,
        "title": "Layer in Docs, Governance, and Recommended Checks",
        "description": "Add documentation standards, governance files, integration testing, performance baselines, complexity analysis, accessibility auditing, and (optionally) ML-specific practices for data-heavy Python repos.",
        "focusIds": [
          "documentation",
          "repository-governance",
          "integration-testing",
          "performance-baselining",
          "complexity-analysis",
          "accessibility-auditing"
        ],
        "notes": "Tackle recommended items in order of business value; backend-only repos can skip web-focused checks like accessibility."
      },
      {
        "step": 5,
        "title": "AI/ML Governance (If Applicable)",
        "description": "For repos using or building with generative AI, add drift detection, schema enforcement, golden contract tests, safety testing, and provenance tracking.",
        "focusIds": [
          "ai-drift-detection",
          "ai-schema-enforcement",
          "ai-golden-tests",
          "ai-safety-checks",
          "ai-provenance-tracking"
        ],
        "notes": "Skip this step if your repo has no AI/ML components. For AI-heavy repos: add nightly drift detection to catch model changes, enforce strict schemas at AI output boundaries, and log provenance for debugging 'why did AI do X?'"
      }
    ],
    "executorHints": {
      "description": "Advisory execution substrate hints. Bazel is the first supported executor; future monorepo executors may follow the same pattern.",
      "bazel": {
        "detectionRules": {
          "rootMarkers": ["MODULE.bazel", "WORKSPACE.bazel", "WORKSPACE"],
          "optionalMarkers": [".bazelrc", ".bazelversion"],
          "notes": "Detection uses repo-root markers only. Nested BUILD files do not trigger Bazel mode."
        },
        "optOut": {
          "description": "Set meta.executorHints.bazel.enabled = false in repo config to disable Bazel hints",
          "configPath": "meta.executorHints.bazel.enabled"
        },
        "targetConventions": {
          "description": "Recommended target naming (not assumed to exist). These are illustrative patterns; actual targets are repo-defined.",
          "lint": "//tools/lint:lint or bazel test //... with lint aspects",
          "format": "bazel run //tools/format:check",
          "test": "bazel test //...",
          "coverage": "bazel coverage //...",
          "build": "bazel build //..."
        },
        "ciContract": {
          "versionPinning": "Use .bazelversion file for Bazelisk",
          "configFlag": "--config=ci (define in .bazelrc)",
          "deterministicFlags": ["--nokeep_going", "--test_output=errors"],
          "remoteCache": "Optional; not required for CI"
        },
        "advisoryNotice": "bazelHints are suggestions, not required execution paths. Consumers should prefer stack-native commands unless explicitly adopting Bazel."
      }
    }
  },
  "checklist": {
    "core": [
      {
        "id": "gitattributes-eol",
        "label": "Git Attributes (Line Endings)",
        "description": "Enforce line endings at the Git layer using .gitattributes. Mark text files with appropriate EOL handling (eol=lf for shell scripts, eol=auto for most files) and binary files as binary to prevent corruption. This prevents 'works locally, fails in CI' issues caused by CRLF/LF mismatches.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection early in pipeline before other checks."
          }
        },
        "stack": {
          "exampleTools": ["git"],
          "exampleConfigFiles": [".gitattributes", ".editorconfig"],
          "notes": "Go files should use LF for consistency. Mark *.go as text. Shell scripts (*.sh) must use eol=lf. Binary artifacts should be marked as binary.",
          "verification": "Run 'git ls-files --eol' to verify EOL handling.",
          "requiredFiles": [".gitattributes"],
          "optionalFiles": [".editorconfig"],
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Verify no CRLF in shell scripts"
          }
        }
      },
      {
        "id": "crlf-detection",
        "label": "CRLF Detection in CI",
        "description": "Fail CI early for Linux-executed files containing CRLF line endings. Shell scripts, Python files, and other interpreted files fail silently or with cryptic errors when they contain \\r characters. Detect this before running deeper CI steps.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection as the first quality check before linting or testing."
          }
        },
        "stack": {
          "exampleTools": ["file", "grep"],
          "exampleConfigFiles": [],
          "notes": "Go source files tolerate CRLF but shell scripts and Makefiles do not. Check .sh, Makefile, and go.mod for CRLF.",
          "verification": "Run CRLF detection on shell scripts and Makefiles.",
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(sh|bash)$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Detect CRLF in shell scripts"
          }
        }
      },
      {
        "id": "gitignore-and-dockerignore",
        "label": "Git and Docker Ignore Files",
        "description": "Maintain proper .gitignore and .dockerignore files to prevent committing secrets, build artifacts, or unnecessary files.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleConfigFiles": [".gitignore", ".dockerignore"],
          "notes": "Use the official github/gitignore Go template. Exclude vendor/ (if not vendoring), *.exe, *.test, *.out, and IDE-specific files. .dockerignore must exclude .git and local build output.",
          "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
          "requiredFiles": [".gitignore"],
          "optionalFiles": [".dockerignore"]
        }
      },
      {
        "id": "linting",
        "label": "Linting",
        "description": "Run static code linting to enforce consistency and catch common issues early.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["golangci-lint", "staticcheck"],
          "exampleConfigFiles": [".golangci.yml", ".golangci.yaml"],
          "notes": "Use golangci-lint as the primary linter aggregator. Configure enabled linters in .golangci.yml for consistent team-wide enforcement.",
          "verification": ".golangci.yml or .golangci.yaml indicates linting is configured. Run 'golangci-lint run' to verify.",
          "requiredFiles": ["go.mod"],
          "optionalFiles": [".golangci.yml", ".golangci.yaml"],
          "bazelHints": {
            "commands": [
              "bazel test //... --@io_bazel_rules_go//go/config:nogo=@//:nogo"
            ],
            "notes": "Use nogo for static analysis via rules_go. Configure nogo target with desired analyzers."
          }
        }
      },
      {
        "id": "unit-test-runner",
        "label": "Unit Test Runner",
        "description": "Provide a deterministic unit test framework with a single command to run all tests.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["go test"],
          "exampleConfigFiles": ["go.mod"],
          "notes": "Use 'go test ./...' to run all tests. Place test files alongside source files with _test.go suffix. Keep unit tests fast and isolated.",
          "verification": "Run 'go test ./...' to verify the test suite is configured and passing.",
          "requiredFiles": ["go.mod"],
          "optionalFiles": [],
          "bazelHints": {
            "commands": ["bazel test //..."],
            "notes": "rules_go go_test targets wrap 'go test' with Bazel's caching and hermeticity."
          }
        }
      },
      {
        "id": "containerization",
        "label": "Containerization (Docker / Docker Compose)",
        "description": "Provide a Dockerfile and, if applicable, a docker-compose file for local dev and CI parity.",
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
          "notes": "Use multi-stage builds: builder stage with golang:alpine, then copy binary to scratch or distroless for minimal runtime. Set CGO_ENABLED=0 for static binaries.",
          "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
          "requiredFiles": ["Dockerfile"],
          "optionalFiles": ["docker-compose.yml"]
        }
      },
      {
        "id": "semantic-versioning",
        "label": "Semantic Versioning",
        "description": "Use MAJOR.MINOR.PATCH versioning with clear rules and automated changelog generation based on commit history. Maintain a single canonical version source (for example, package.json or VERSION) that all release artifacts use.",
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          }
        },
        "stack": {
          "exampleTools": ["goreleaser", "semantic-release"],
          "exampleConfigFiles": [".goreleaser.yml", "CHANGELOG.md"],
          "notes": "Go uses git tags (v1.2.3) as the canonical version source. Use goreleaser for automated releases with changelog generation and publish GitHub/Docker artifacts from the same tag.",
          "verification": "Check that git tags follow vMAJOR.MINOR.PATCH format and goreleaser or similar tooling generates releases and changelogs.",
          "optionalFiles": [".goreleaser.yml", "CHANGELOG.md"],
          "requiredScripts": ["release"]
        }
      },
      {
        "id": "unified-release-workflow",
        "label": "Unified Release Workflow",
        "description": "Use a single CI release pipeline that publishes all artifacts (GitHub releases, packages, containers) from the same canonical version source.",
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          }
        },
        "stack": {
          "exampleTools": ["goreleaser", "docker buildx"],
          "exampleConfigFiles": [
            ".github/workflows/release.yml",
            "azure-pipelines.yml"
          ],
          "notes": "Use a single release pipeline (goreleaser or equivalent) to publish GitHub releases and Docker images from the same git tag.",
          "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
          "requiredScripts": ["release"],
          "optionalFiles": [".goreleaser.yml", "CHANGELOG.md"]
        }
      },
      {
        "id": "release-hook-bypass",
        "label": "Release Hook Bypass",
        "description": "Release automation must bypass local developer hooks (HUSKY=0, --no-verify) and rely solely on CI gates for validation. This ensures idempotent, reproducible releases that don't fail due to hook environment differences.",
        "ciHints": {
          "azure-devops": {
            "stage": "release",
            "notes": "Set HUSKY=0 or equivalent in release pipeline to disable hooks."
          }
        },
        "stack": {
          "exampleTools": ["goreleaser"],
          "exampleConfigFiles": [
            ".goreleaser.yml",
            ".github/workflows/release.yml"
          ],
          "notes": "Goreleaser handles releases without invoking local hooks. Ensure any git operations use --no-verify.",
          "verification": "Check release workflow for hook bypass configuration."
        }
      },
      {
        "id": "commit-linting",
        "label": "Commit Linting",
        "description": "Enforce structured commit messages such as Conventional Commits via commit-msg hooks and CI. This is required for deterministic versioning and changelog generation.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["commitlint", "commitizen"],
          "exampleConfigFiles": ["commitlint.config.js", ".cz.toml"],
          "notes": "Use commitlint with commit-msg or pre-commit hooks plus a CI check. Conventional Commits keep goreleaser changelog generation deterministic.",
          "verification": "Test that non-conforming commit messages are rejected by the configured hooks and CI check.",
          "anyOfFiles": [
            "commitlint.config.js",
            "commitlint.config.cjs",
            "commitlint.config.mjs",
            "commitlint.config.json",
            ".cz.toml"
          ],
          "requiredScripts": ["commitlint"]
        }
      },
      {
        "id": "unit-test-reporter",
        "label": "Unit Test Reporter / Coverage",
        "description": "Generate readable unit test and coverage reports and enforce a minimum coverage threshold (around 80%) for new or changed code.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["go test -cover", "go tool cover"],
          "exampleConfigFiles": ["go.mod"],
          "notes": "Use 'go test -coverprofile=coverage.out ./...' for coverage. Generate HTML or integrate with codecov/coveralls.",
          "verification": "Run 'go test -cover ./...' and verify coverage reports are produced and thresholds monitored.",
          "bazelHints": {
            "commands": ["bazel coverage //..."],
            "notes": "rules_go supports coverage via bazel coverage. Use --combined_report=lcov for aggregated output."
          }
        }
      },
      {
        "id": "ci-quality-gates",
        "label": "CI Quality Gates",
        "description": "Single CI pipeline that runs linting, formatting, type checking, tests, coverage, build, and containerization.",
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [".github/workflows/*", "azure-pipelines.yml"],
          "notes": "Run 'golangci-lint run', 'go test ./...', 'go build' as quality gates. Use govulncheck for security scanning.",
          "verification": "Verify CI runs golangci-lint, go test, and go build before merging to main.",
          "bazelHints": {
            "commands": ["bazel build //...", "bazel test //..."],
            "notes": "rules_go go_binary and go_test targets provide hermetic builds and tests."
          }
        }
      },
      {
        "id": "code-formatter",
        "label": "Code Formatter",
        "description": "Automatic code formatting to maintain a consistent style across all contributors.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["gofmt", "goimports"],
          "exampleConfigFiles": [],
          "notes": "Use gofmt (built-in) for formatting. goimports extends gofmt with import organization. Formatting is enforced by convention.",
          "verification": "Run 'gofmt -d .' or 'goimports -d .' and confirm no output indicates clean formatting.",
          "bazelHints": {
            "commands": ["bazel run @go_sdk//:bin/gofmt -- -d ."],
            "notes": "Run gofmt via the Bazel-managed Go SDK for hermetic formatting checks."
          }
        }
      },
      {
        "id": "pre-commit-hooks",
        "label": "Pre-Commit Hooks",
        "description": "Use git hooks to run linting, formatting, and commit linting before changes are committed. Hooks should CHECK by default (not auto-fix), be fast, and scope to changed files only. Use a single entry hook mechanism (e.g., Husky as entry point calling pre-commit or lint-staged).",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Hooks and CI must invoke identical verification commands. Use npm run verify or equivalent."
          }
        },
        "stack": {
          "exampleTools": ["pre-commit", "lefthook"],
          "exampleConfigFiles": [".pre-commit-config.yaml", "lefthook.yml"],
          "notes": "Use pre-commit or lefthook with go hooks for 'gofmt -d' (check mode) and golangci-lint. Pin Go version in go.mod and .go-version for determinism.",
          "verification": "Confirm hooks run format checks (not auto-fix) and golangci-lint before commits."
        }
      },
      {
        "id": "hook-ci-parity",
        "label": "Hook/CI Parity",
        "description": "Local hooks and CI must invoke identical verification commands to prevent 'works locally, fails in CI' issues. Use a single canonical verify entrypoint (e.g., npm run verify) that both hooks and CI call.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the same verify script that hooks use locally."
          }
        },
        "stack": {
          "exampleTools": ["make", "mage"],
          "exampleConfigFiles": ["Makefile", "magefile.go"],
          "notes": "Define a verify target (make verify) that runs go vet, golangci-lint, and go test. Both hooks and CI should use this target.",
          "verification": "Compare hook commands with CI commands and confirm they invoke the same make targets."
        }
      },
      {
        "id": "secret-scanning-precommit",
        "label": "Pre-commit Secret Scanning",
        "description": "Scan staged diffs for credentials, API keys, and secrets before they reach the remote repository. Catch secrets at commit time rather than after they're pushed.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Also run secret scanning in CI as a safety net for commits that bypassed hooks."
          }
        },
        "stack": {
          "exampleTools": ["gitleaks", "trufflehog"],
          "exampleConfigFiles": [".gitleaks.toml", ".pre-commit-config.yaml"],
          "notes": "Add gitleaks to pre-commit hooks. Scan staged changes only for speed.",
          "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
        }
      },
      {
        "id": "type-checking",
        "label": "Type Checking",
        "description": "Use static type checking to catch errors before runtime and enforce strictness on new code. For JS/TS stacks, require a TypeScript-first policy with strict mode and a CI typecheck step; allow JSDoc/checkJs migration for legacy JS.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["go vet", "staticcheck"],
          "exampleConfigFiles": ["go.mod"],
          "notes": "Go has compile-time type checking built in. Use 'go vet' for additional static analysis. staticcheck provides enhanced type-related checks.",
          "verification": "Run 'go build ./...' to verify type correctness. Use 'go vet ./...' for additional static analysis.",
          "requiredFiles": ["go.mod"],
          "bazelHints": {
            "commands": ["bazel build //..."],
            "notes": "Go type checking is inherent to compilation. bazel build with rules_go enforces type safety."
          }
        }
      },
      {
        "id": "dependency-security",
        "label": "Dependency Management & Vulnerability Scanning",
        "description": "Lock dependencies and scan regularly for known vulnerabilities; fail CI on newly introduced high-severity issues.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["govulncheck", "nancy"],
          "exampleConfigFiles": ["go.sum"],
          "notes": "Use govulncheck (official Go tool) for vulnerability scanning. go.sum locks dependency checksums for reproducible builds.",
          "verification": "go.sum is present; run 'govulncheck ./...' to verify security scanning.",
          "requiredFiles": ["go.sum"]
        }
      },
      {
        "id": "deterministic-builds",
        "label": "Deterministic & Hermetic Builds",
        "description": "Ensure builds are reproducible by pinning dependencies, base images, and tool/runtime versions. Avoid network/time variance and fail when lockfiles drift.",
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          }
        },
        "stack": {
          "exampleTools": ["go env -w GOPROXY=off", "go mod download"],
          "exampleConfigFiles": ["go.sum", "go.mod", ".go-version"],
          "notes": "Use go.sum for deterministic module versions and pin Go versions (go.mod + .go-version). Avoid network variance by caching modules and pinning proxies.",
          "verification": "go.sum is present and builds use pinned Go versions; module downloads are cached.",
          "requiredFiles": ["go.sum"],
          "optionalFiles": [".go-version"]
        }
      },
      {
        "id": "provenance-security",
        "label": "Provenance & Security Metadata",
        "description": "Produce SBOMs or provenance metadata, enable secret/code scanning, and sign tags or commits for critical repos.",
        "ciHints": {
          "azure-devops": {
            "stage": "security"
          }
        },
        "stack": {
          "exampleTools": [
            "syft",
            "cyclonedx-gomod",
            "codeql",
            "gitleaks",
            "cosign"
          ],
          "exampleConfigFiles": [
            ".github/workflows/codeql.yml",
            ".github/workflows/provenance.yml"
          ],
          "notes": "Generate SBOM/provenance for Go binaries and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
          "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
          "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
        }
      },
      {
        "id": "ci-templates-automation",
        "label": "CI Templates & Automation",
        "description": "Adopt standard CI templates and config samples to scale across repositories, minimizing bespoke pipeline logic.",
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          }
        },
        "stack": {
          "exampleTools": [
            "GitHub Actions reusable workflows",
            "Azure DevOps templates"
          ],
          "exampleConfigFiles": [
            ".github/workflows/ci.yml",
            "azure-pipelines.yml"
          ],
          "notes": "Use shared CI templates for build/test/release stages to standardize across Go repos.",
          "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
          "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
          "requiredScripts": ["ci"]
        }
      },
      {
        "id": "runtime-version",
        "label": "Runtime Version Specification",
        "description": "Specify required runtime/engine versions in package manifests to ensure environment stability and prevent version-related issues across development teams.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["go.mod", ".go-version"],
          "notes": "Specify 'go' directive in go.mod (e.g., go 1.21) to set minimum Go version. Consider .go-version for goenv users.",
          "verification": "go.mod must contain 'go' directive specifying minimum version; .go-version is optional for local development.",
          "requiredFiles": ["go.mod"],
          "optionalFiles": [".go-version"]
        }
      },
      {
        "id": "documentation",
        "label": "Documentation Standards",
        "description": "Maintain a comprehensive README and, where applicable, auto-generated API docs to support onboarding and maintainability.",
        "ciHints": {
          "azure-devops": {
            "stage": "docs"
          }
        },
        "stack": {
          "exampleTools": ["godoc", "pkgsite"],
          "exampleConfigFiles": ["README.md", "docs/"],
          "notes": "Use godoc or pkgsite for API documentation from code comments. Follow Go documentation conventions.",
          "verification": "README.md is present; documentation comments exist in exported functions/types.",
          "requiredFiles": ["README.md"],
          "optionalFiles": ["docs/"]
        }
      },
      {
        "id": "repository-governance",
        "label": "Repository Governance",
        "description": "Include standard governance files (LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md), branch protection rules, and review standards to define legal, ethical, and workflow expectations.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            "LICENSE",
            "CODE_OF_CONDUCT.md",
            "CONTRIBUTING.md"
          ],
          "notes": "Include license identifier in go.mod comments if needed. Document Go module conventions and testing requirements in CONTRIBUTING.md.",
          "verification": "LICENSE file is present; CODE_OF_CONDUCT.md and CONTRIBUTING.md provide contribution guidance.",
          "requiredFiles": ["LICENSE"],
          "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
        }
      },
      {
        "id": "canonical-verify",
        "label": "Canonical Verify Entrypoint",
        "description": "Provide one canonical 'verify' command per repository/stack that all stages call with appropriate flags. This prevents duplication, drift, and ensures consistency between local development and CI.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the canonical verify command, not duplicate check logic."
          }
        },
        "stack": {
          "exampleTools": ["make", "mage"],
          "exampleConfigFiles": ["Makefile", "magefile.go"],
          "notes": "Define 'make verify' that runs go vet, golangci-lint, and go test. All stages use this single entrypoint.",
          "verification": "Makefile contains a 'verify' target."
        }
      },
      {
        "id": "config-authority",
        "label": "Config File Authority Rules",
        "description": "Each configuration rule must live in exactly one authoritative config file. Avoid duplication across .editorconfig, linter configs, and CI definitions. Document which file is authoritative for each concern.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Ensure CI reads from authoritative configs, not duplicated settings."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [".gitattributes", "go.mod", ".golangci.yml"],
          "notes": "Authority mapping: .gitattributes for EOL, go.mod for module config and Go version, .golangci.yml for all linting rules. Keep lint config consolidated in one file.",
          "verification": "Review configs and confirm .golangci.yml is the single source for lint rules."
        }
      },
      {
        "id": "explicit-skip-paths",
        "label": "Explicit Skip Paths",
        "description": "Encode path exclusions and skip rules deterministically in config files, not through ad-hoc human judgment. Make it clear which paths are excluded from checks and why.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should read skip paths from config files, not hardcode them in pipeline."
          }
        },
        "stack": {
          "exampleTools": ["golangci-lint"],
          "exampleConfigFiles": [".golangci.yml"],
          "notes": "Define skip-dirs and skip-files in .golangci.yml. Use //nolint comments sparingly and always include justification (//nolint:errcheck // reason).",
          "verification": "Review .golangci.yml and confirm skip paths are explicit and documented."
        }
      }
    ],
    "recommended": [
      {
        "id": "dependency-update-automation",
        "label": "Dependency Update Automation",
        "description": "Automate dependency updates using Renovate or Dependabot to keep dependencies current and reduce security exposure window.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          }
        },
        "stack": {
          "exampleTools": ["renovate", "dependabot"],
          "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
          "notes": "Both support go.mod/go.sum. Renovate handles replace directives better. Security scanning is covered by dependency-security (govulncheck).",
          "verification": "Check for renovate.json OR .github/dependabot.yml. Verify Go module PRs.",
          "anyOfFiles": [
            "renovate.json",
            ".renovaterc.json",
            ".github/dependabot.yml"
          ]
        }
      },
      {
        "id": "dependency-architecture-rules",
        "label": "Dependency Architecture Rules",
        "description": "Enforce module boundaries and import constraints to prevent architectural drift and unwanted coupling.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          }
        },
        "stack": {
          "exampleTools": ["depaware", "go-mod-check"],
          "exampleConfigFiles": [],
          "notes": "Go's module system is simpler. Use internal/ packages for visibility. depaware provides transitive dep analysis. Standard practice: 'go mod tidy && git diff --exit-code go.mod go.sum'.",
          "verification": "Run 'go mod verify' and 'go mod tidy' with diff check in CI."
        }
      },
      {
        "id": "integration-testing",
        "label": "Integration Testing",
        "description": "Test how components interact with each other and external systems, running after unit tests with more relaxed coverage thresholds.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["go test"],
          "exampleConfigFiles": ["*_test.go"],
          "notes": "Use build tags (//go:build integration) or separate test directories for integration tests. Run with 'go test -tags=integration ./...'.",
          "verification": "Confirm integration tests exist and run 'go test -tags=integration ./...' to verify."
        }
      },
      {
        "id": "performance-baselining",
        "label": "Performance Baselines",
        "description": "Establish performance baselines and monitor for regressions using lightweight benchmarks or audits in CI.",
        "ciHints": {
          "azure-devops": {
            "stage": "performance"
          }
        },
        "stack": {
          "exampleTools": ["go test -bench", "benchstat"],
          "exampleConfigFiles": ["*_test.go"],
          "notes": "Use 'go test -bench=. ./...' for benchmarks. Use benchstat to compare results across runs.",
          "verification": "Run 'go test -bench=. ./...' and verify benchmark results are tracked over time."
        }
      },
      {
        "id": "complexity-analysis",
        "label": "Complexity Analysis",
        "description": "Measure cyclomatic complexity or similar metrics to keep code maintainable, starting as a warning-only check.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["gocyclo", "golangci-lint"],
          "exampleConfigFiles": [".golangci.yml"],
          "notes": "Use gocyclo or golangci-lint's gocyclo linter to measure cyclomatic complexity. Configure threshold in .golangci.yml.",
          "verification": "Run 'gocyclo' or 'golangci-lint run' and review complexity reports, ensuring new code doesn't exceed thresholds."
        }
      },
      {
        "id": "accessibility-auditing",
        "label": "Accessibility Auditing",
        "description": "Run accessibility checks on web-facing components to detect critical issues and improve inclusive UX.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["axe-core", "pa11y"],
          "exampleConfigFiles": [],
          "notes": "For Go web apps, use headless browser-based accessibility tools to audit rendered HTML from templates.",
          "verification": "For web-facing Go apps, run accessibility audits against key routes using axe or pa11y."
        }
      },
      {
        "id": "ai-drift-detection",
        "label": "AI Drift Detection",
        "description": "Run nightly or scheduled checks comparing AI-generated outputs against pinned baselines to detect model drift, prompt drift, or code changes affecting AI behavior. Attribute regressions to code changes vs model updates vs prompt changes.",
        "ciHints": {
          "azure-devops": {
            "stage": "nightly",
            "notes": "Run AI drift detection in a scheduled nightly pipeline separate from main CI."
          }
        },
        "stack": {
          "exampleTools": ["go test", "golden files"],
          "exampleConfigFiles": ["testdata/golden/", "ai-baselines/"],
          "notes": "Use golden file testing pattern for AI outputs. Compare current output against pinned baselines nightly.",
          "verification": "Run golden tests and confirm AI outputs match baselines."
        }
      },
      {
        "id": "ai-schema-enforcement",
        "label": "AI Output Schema Enforcement",
        "description": "Validate all AI-generated outputs against strict JSON schemas or type definitions at system boundaries. Reject invalid outputs early rather than letting malformed data propagate through the system.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run schema validation tests as part of quality gates."
          }
        },
        "stack": {
          "exampleTools": ["go-playground/validator", "gojsonschema"],
          "exampleConfigFiles": ["schemas/"],
          "notes": "Define struct tags for JSON unmarshaling and use validator for additional constraints. Reject AI outputs that don't match expected schema.",
          "verification": "Review AI integration code and confirm schema validation is in place."
        }
      },
      {
        "id": "ai-golden-tests",
        "label": "AI Golden Contract Tests",
        "description": "Validate AI tool-generated patches, configs, and code against exact expected formats. Test that AI outputs respect forbidden paths, file patterns, and format constraints through golden contract tests.",
        "ciHints": {
          "azure-devops": {
            "stage": "test",
            "notes": "Run AI golden tests as part of the test stage."
          }
        },
        "stack": {
          "exampleTools": ["go test", "golden files"],
          "exampleConfigFiles": ["testdata/"],
          "notes": "Use golden file pattern for AI output testing. Verify generated code follows Go conventions and doesn't modify vendor/ or other protected paths.",
          "verification": "Run golden tests and confirm AI outputs match expected files."
        }
      },
      {
        "id": "ai-safety-checks",
        "label": "AI Adversarial & Safety Testing",
        "description": "Test AI integrations for prompt injection resistance, input sanitization, output filtering, and data exfiltration prevention. Include adversarial test cases that attempt to manipulate AI behavior.",
        "ciHints": {
          "azure-devops": {
            "stage": "security",
            "notes": "Run AI safety tests as part of security stage on main branch."
          }
        },
        "stack": {
          "exampleTools": ["go test", "go-fuzz"],
          "exampleConfigFiles": ["ai_safety_test.go"],
          "notes": "Create adversarial test cases for AI integrations. Use fuzzing to discover input handling edge cases.",
          "verification": "Run AI safety tests and fuzz tests."
        }
      },
      {
        "id": "ai-provenance-tracking",
        "label": "AI Provenance & Audit Logging",
        "description": "Log AI provider, model version, prompt template version, parameters, and tool versions for all AI operations. Enable attribution of outputs to specific model+prompt combinations for debugging and compliance.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Verify AI provenance logging is implemented in quality checks."
          }
        },
        "stack": {
          "exampleTools": ["slog", "OpenTelemetry"],
          "exampleConfigFiles": ["ai/provenance.go"],
          "notes": "Use structured logging (slog) to capture AI provenance. Include model, prompt version, and parameters in log context.",
          "verification": "Review AI integration and confirm provenance logging is implemented."
        }
      },
      {
        "id": "agent-invariants",
        "label": "Autonomous Agent Invariants",
        "description": "Maintain INVARIANTS.md defining repository-wide rules that must always hold true, with machine-readable verification commands for autonomous agents.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run invariant verification commands in a dedicated quality stage."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["INVARIANTS.md"],
          "notes": "Specify invariants with commands like 'go test ./...', 'golangci-lint run', 'go vet ./...' that agents can use for validation.",
          "verification": "INVARIANTS.md exists with machine-readable verification commands.",
          "requiredFiles": ["INVARIANTS.md"]
        }
      }
    ],
    "optionalEnhancements": [
      {
        "id": "observability",
        "label": "Observability (Logging & Error Handling)",
        "description": "Standardize error handling and structured logging to make debugging and production monitoring easier.",
        "ciHints": {
          "azure-devops": {
            "stage": "observability"
          }
        },
        "stack": {
          "exampleTools": ["slog", "zap", "zerolog"],
          "exampleConfigFiles": [],
          "notes": "Use slog (stdlib) or zap/zerolog for structured logging. Configure JSON output for production and text for development.",
          "verification": "Confirm that a structured logging library is configured with appropriate output format and log levels."
        }
      },
      {
        "id": "agent-phase-gates",
        "label": "Agent Phase Gates",
        "description": "Define phase transition requirements in phase-gates.md for autonomous agent workflows with clear pre-conditions and approval gates.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["phase-gates.md"],
          "notes": "Define gates with Go-specific checks (go test, go vet, module tagging) and approval workflows for phase transitions.",
          "verification": "phase-gates.md exists defining transition requirements.",
          "optionalFiles": ["phase-gates.md"]
        }
      },
      {
        "id": "agent-victory-gates",
        "label": "Agent Victory Gates",
        "description": "Document milestone completion criteria in victory-gates.md defining 'done' for releases and major deliverables with evidence requirements.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["victory-gates.md"],
          "notes": "Specify completion gates with Go-specific requirements (module tagging, pkg.go.dev documentation, binary distribution) and validation artifacts.",
          "verification": "victory-gates.md exists with milestone criteria.",
          "optionalFiles": ["victory-gates.md"]
        }
      }
    ]
  }
}
