{
  "version": 2,
  "stack": "typescript-js",
  "stackLabel": "TypeScript / JavaScript",
  "ciSystems": ["azure-devops", "github-actions"],
  "meta": {
    "defaultCoverageThreshold": 0.8,
    "complexityChecks": {
      "enabledByDefault": true,
      "description": "When supported by the stack, run cyclomatic complexity or similar metrics in CI as a warning-only check initially."
    },
    "qualityGatePolicy": {
      "preferSoftFailOnLegacy": true,
      "description": "New quality checks should warn on existing code and fail CI only for violations introduced in new or changed code, to reduce friction on legacy codebases."
    },
    "migrationGuide": [
      {
        "step": 1,
        "title": "Establish Local Safety Nets First",
        "description": "Start by adding pre-commit hooks and core formatting/linting so developers get fast feedback without touching CI.",
        "focusIds": ["pre-commit-hooks", "linting", "code-formatter"],
        "notes": "Keep hooks fast and focused on changed files to avoid slowing down day-to-day work."
      },
      {
        "step": 2,
        "title": "Mirror Local Checks in CI (Soft-Fail on Legacy)",
        "description": "Introduce CI quality gates that mirror local checks, but treat existing violations as warnings wherever possible.",
        "focusIds": [
          "ci-quality-gates",
          "linting",
          "code-formatter",
          "commit-linting"
        ],
        "notes": "Use diff-based tools or baselines so only new violations break builds; legacy issues remain visible but non-blocking."
      },
      {
        "step": 3,
        "title": "Add Type Safety, Coverage, and Dependency Security",
        "description": "Enable type-checking, coverage thresholds, and dependency/vulnerability scanning with gradual enforcement.",
        "focusIds": [
          "type-checking",
          "unit-test-runner",
          "unit-test-reporter",
          "dependency-security",
          "dependency-update-automation"
        ],
        "notes": "Pin tool and runtime versions in CI and containers to avoid flaky differences across environments."
      },
      {
        "step": 4,
        "title": "Layer in Docs, Governance, and Recommended Checks",
        "description": "Add documentation standards, governance files, integration testing, performance baselines, complexity analysis, accessibility auditing, and (optionally) ML-specific practices for data-heavy Python repos.",
        "focusIds": [
          "documentation",
          "repository-governance",
          "integration-testing",
          "performance-baselining",
          "complexity-analysis",
          "accessibility-auditing"
        ],
        "notes": "Tackle recommended items in order of business value; backend-only repos can skip web-focused checks like accessibility. For AI/ML-heavy Python teams, consider extending containerization with data versioning (DVC) and unit tests with data quality checks (e.g., Great Expectations) as part of this step."
      }
    ],
    "bazelIntegration": {
      "description": "Bazel build executor support for quality checks. All hints are ADVISORYâ€”stack-native commands remain the default execution path.",
      "detectionRules": {
        "rootMarkers": ["MODULE.bazel", "WORKSPACE.bazel", "WORKSPACE"],
        "optionalMarkers": [".bazelrc", ".bazelversion"],
        "notes": "Detection uses repo-root markers only. Nested BUILD files do not trigger Bazel mode."
      },
      "optOut": {
        "description": "Set meta.bazelIntegration.enabled = false in repo config to disable Bazel hints",
        "configPath": "meta.bazelIntegration.enabled"
      },
      "targetConventions": {
        "description": "Recommended target naming (not assumed to exist). These are illustrative patterns; actual targets are repo-defined.",
        "lint": "//tools/lint:lint or bazel test //... with lint aspects",
        "format": "bazel run //tools/format:check",
        "test": "bazel test //...",
        "coverage": "bazel coverage //...",
        "build": "bazel build //..."
      },
      "ciContract": {
        "versionPinning": "Use .bazelversion file for Bazelisk",
        "configFlag": "--config=ci (define in .bazelrc)",
        "deterministicFlags": ["--nokeep_going", "--test_output=errors"],
        "remoteCache": "Optional; not required for CI"
      },
      "advisoryNotice": "bazelHints are suggestions, not required execution paths. Consumers should prefer stack-native commands unless explicitly adopting Bazel."
    }
  },
  "checklist": {
    "core": [
      {
        "id": "gitignore-and-dockerignore",
        "label": "Git and Docker Ignore Files",
        "description": "Maintain proper .gitignore and .dockerignore files to prevent committing secrets, build artifacts, or unnecessary files.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleConfigFiles": [".gitignore", ".dockerignore"],
          "notes": "Use the official github/gitignore Node template as a base and add .env*, node_modules, dist/, coverage/, *.log, npm-debug.log*, etc. .dockerignore must exclude node_modules, .git, and local build output.",
          "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
          "requiredFiles": [".gitignore"],
          "optionalFiles": [".dockerignore"]
        }
      },
      {
        "id": "linting",
        "label": "Linting",
        "description": "Run static code linting to enforce consistency and catch common issues early.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["eslint"],
          "exampleConfigFiles": [".eslintrc.*", "eslint.config.js"],
          "notes": "Treat new lint errors as CI failures; keep existing issues as warnings until addressed.",
          "verification": "Presence of eslint.config.js (or any .eslintrc* file) indicates linting is enforced for the repository.",
          "anyOfFiles": [
            "eslint.config.js",
            "eslint.config.mjs",
            "eslint.config.cjs",
            ".eslintrc.js",
            ".eslintrc.cjs",
            ".eslintrc.json",
            ".eslintrc.yaml",
            ".eslintrc.yml"
          ],
          "optionalFiles": [
            ".prettierrc",
            "prettier.config.js",
            "prettier.config.cjs",
            "prettier.config.json",
            "prettier.config.yaml"
          ],
          "requiredScripts": ["lint"],
          "bazelHints": {
            "commands": [
              "bazel test //... --aspects=//tools:lint.bzl%eslint_aspect --output_groups=report"
            ],
            "recommendedTargets": ["//tools/lint:lint"],
            "notes": "Example only; actual targets are repo-defined. Wrap eslint via aspect_rules_lint or a custom sh_test rule."
          }
        }
      },
      {
        "id": "unit-test-runner",
        "label": "Unit Test Runner",
        "description": "Provide a deterministic unit test framework with a single command to run all tests.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["jest"],
          "exampleConfigFiles": ["jest.config.*"],
          "notes": "Keep unit tests fast and deterministic; move slow or flaky tests into integration or E2E suites.",
          "verification": "Test framework configuration is present; test script is defined in package.json.",
          "optionalFiles": [
            "jest.config.js",
            "jest.config.ts",
            "vitest.config.js",
            "vitest.config.ts"
          ],
          "requiredScripts": ["test"],
          "bazelHints": {
            "commands": ["bazel test //..."],
            "notes": "Bazel discovers and runs all test targets. Use rules_js for Jest/Vitest integration."
          }
        }
      },
      {
        "id": "containerization",
        "label": "Containerization (Docker / Docker Compose)",
        "description": "Provide a Dockerfile and, if applicable, a docker-compose file for local dev and CI parity.",
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
          "notes": "Use multi-stage builds and pin Node.js and base image versions in the Dockerfile to match CI (e.g., node:22-alpine).",
          "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
          "requiredFiles": ["Dockerfile"],
          "optionalFiles": ["docker-compose.yml"]
        }
      },
      {
        "id": "semantic-versioning",
        "label": "Semantic Versioning",
        "description": "Use MAJOR.MINOR.PATCH versioning with clear rules and automated changelog generation based on commit history.",
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          },
          "github-actions": {
            "job": "release"
          }
        },
        "stack": {
          "exampleTools": ["semantic-release", "standard-version"],
          "exampleConfigFiles": [".releaserc", "package.json", "CHANGELOG.md"],
          "notes": "Automate version bumping and changelog generation from Conventional Commits using semantic-release or standard-version. Configure CI to automatically bump package.json version, generate/update CHANGELOG.md, create git tags, and publish release artifacts. Protect release branches and ensure release tooling only runs there.",
          "verification": "Check that the version field follows SemVer, and trigger the configured release workflow (for example, a dry run of semantic-release or standard-version) to confirm it automatically generates the expected next version, updates package.json, and creates/updates CHANGELOG.md with commit-based entries."
        }
      },
      {
        "id": "commit-linting",
        "label": "Commit Linting",
        "description": "Enforce structured commit messages such as Conventional Commits.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [
            "@commitlint/cli",
            "@commitlint/config-conventional"
          ],
          "exampleConfigFiles": ["commitlint.config.*"],
          "notes": "Enforce commit message format via commit-msg hooks (e.g., Husky) before CI.",
          "verification": "Create a test commit using the documented convention and ensure the commit message passes the configured commit linting or wizard (for example, commitlint or commitizen)."
        }
      },
      {
        "id": "unit-test-reporter",
        "label": "Unit Test Reporter / Coverage",
        "description": "Generate readable unit test and coverage reports and enforce a minimum coverage threshold (around 80%) for new or changed code.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["jest", "nyc"],
          "exampleConfigFiles": ["jest.config.*"],
          "notes": "Collect coverage in lcov or similar format; use diff coverage so legacy gaps are visible but non-blocking.",
          "verification": "Run the unit tests with coverage enabled and confirm that a coverage report is produced and that the configured threshold (around 80%) is enforced for new changes.",
          "bazelHints": {
            "commands": ["bazel coverage //..."],
            "notes": "Bazel coverage collects coverage data from all test targets. Use --combined_report=lcov for aggregated reports."
          }
        }
      },
      {
        "id": "ci-quality-gates",
        "label": "CI Quality Gates",
        "description": "Single CI pipeline that runs linting, formatting, type checking, tests, coverage, build, and containerization.",
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [".github/workflows/*", "azure-pipelines.yml"],
          "notes": "Expose a single npm script (e.g., `npm run ci`) that mirrors the CI pipeline so contributors can reproduce failures locally.",
          "verification": "Open the CI configuration and verify there is a job or stage that runs linting, type checking, tests, build, and any required container checks before merging to main.",
          "bazelHints": {
            "commands": ["bazel build //...", "bazel test //..."],
            "notes": "Replace npm run ci with Bazel commands. All quality gates run as Bazel targets."
          }
        }
      },
      {
        "id": "code-formatter",
        "label": "Code Formatter",
        "description": "Automatic code formatting to maintain a consistent style across all contributors.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["prettier"],
          "exampleConfigFiles": [".prettierrc.*", ".prettierignore"],
          "notes": "Run Prettier in check mode in CI; auto-fix locally via pre-commit hooks or editor integration.",
          "verification": "Run the formatter in check mode (for example, `npm run format:check`) and confirm it reports clean formatting on committed code and auto-fixes as expected locally.",
          "bazelHints": {
            "commands": [
              "bazel run //tools/format:check",
              "bazel test //...:format_test"
            ],
            "notes": "Wrap Prettier as a run target for formatting checks. Use aspect_rules_lint for format aspects."
          }
        }
      },
      {
        "id": "pre-commit-hooks",
        "label": "Pre-Commit Hooks",
        "description": "Use git hooks to run linting, formatting, tests, and commit linting before changes are committed.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["husky", "lint-staged"],
          "exampleConfigFiles": [".husky/", "package.json"],
          "notes": "Run ESLint and Prettier on staged files and enforce commit message format via commit-msg hooks.",
          "verification": "Inspect the pre-commit and commit-msg hooks (for example, files under .husky or other hook tooling) and confirm they run linting/formatting and commit linting on staged changes."
        }
      },
      {
        "id": "type-checking",
        "label": "Type Checking",
        "description": "Use static type checking to catch errors before runtime and enforce strictness on new code.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["TypeScript compiler (tsc)"],
          "exampleConfigFiles": ["tsconfig.json"],
          "notes": "Enable strict mode ('strict': true) and treat type-check failures as CI failures for new code; gradually expand strictness into legacy modules.",
          "verification": "Presence of tsconfig.json indicates type-checking is configured for the repository.",
          "requiredFiles": ["tsconfig.json"],
          "requiredScripts": ["typecheck"],
          "bazelHints": {
            "commands": ["bazel build //..."],
            "notes": "TypeScript type errors surface during bazel build with rules_ts. No separate typecheck step needed."
          }
        }
      },
      {
        "id": "dependency-security",
        "label": "Dependency Management & Vulnerability Scanning",
        "description": "Lock dependencies and scan regularly for known vulnerabilities; fail CI on newly introduced high-severity issues.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["npm audit", "Snyk"],
          "exampleConfigFiles": [
            "package-lock.json",
            "pnpm-lock.yaml",
            "yarn.lock"
          ],
          "notes": "Require a lockfile for reproducible installs and pin Node.js/tooling versions; block merges on new high-severity vulnerabilities.",
          "verification": "Dependency lockfile is present; security scanning is configured in CI or project tooling.",
          "optionalFiles": ["package-lock.json", "pnpm-lock.yaml", "yarn.lock"]
        }
      },
      {
        "id": "runtime-version",
        "label": "Runtime Version Specification",
        "description": "Specify required runtime/engine versions in package manifests to ensure environment stability and prevent version-related issues across development teams.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["package.json"],
          "notes": "Specify the 'engines' field in package.json to define the required Node.js version (e.g., \"engines\": { \"node\": \">=18.0.0\" }). This helps prevent environment-related bugs and ensures all developers use compatible Node.js versions.",
          "verification": "package.json must contain an 'engines' field specifying the required Node.js version.",
          "requiredFiles": ["package.json"]
        }
      },
      {
        "id": "documentation",
        "label": "Documentation Standards",
        "description": "Maintain a comprehensive README and, where applicable, auto-generated API docs to support onboarding and maintainability.",
        "ciHints": {
          "azure-devops": {
            "stage": "docs"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["JSDoc", "TypeDoc"],
          "exampleConfigFiles": ["README.md", "docs/"],
          "notes": "README should describe setup, scripts, and architecture; generate API docs from TypeScript types and JSDoc where helpful.",
          "verification": "README.md is present in the repository root; docs/ directory or documentation tooling configuration exists if applicable.",
          "requiredFiles": ["README.md"],
          "optionalFiles": ["docs/", "typedoc.json"]
        }
      },
      {
        "id": "repository-governance",
        "label": "Repository Governance",
        "description": "Include standard governance files (LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md), branch protection rules, and review standards to define legal, ethical, and workflow expectations.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            "LICENSE",
            "CODE_OF_CONDUCT.md",
            "CONTRIBUTING.md"
          ],
          "notes": "Use an SPDX license identifier in package.json and describe review expectations, tests, and docs requirements in CONTRIBUTING.md.",
          "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
          "requiredFiles": ["LICENSE"],
          "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
        }
      }
    ],
    "recommended": [
      {
        "id": "dependency-update-automation",
        "label": "Dependency Update Automation",
        "description": "Automate dependency updates using Renovate or Dependabot to keep dependencies current and reduce security exposure window.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stack": {
          "exampleTools": ["renovate", "dependabot"],
          "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
          "notes": "Renovate supports GHA + AzDO (self-hosted or Mend Renovate App). Dependabot is GitHub-native only. For AzDO: use Renovate via self-hosted runner, Docker container job, or Mend's hosted service.",
          "verification": "Check for renovate.json (or .renovaterc.json) OR .github/dependabot.yml. Verify dependency update PRs are being created.",
          "anyOfFiles": [
            "renovate.json",
            ".renovaterc.json",
            "renovate.json5",
            ".renovaterc.json5",
            ".github/dependabot.yml"
          ],
          "pinningNotes": "Pin Renovate Docker image version in AzDO pipelines for determinism."
        }
      },
      {
        "id": "dependency-architecture-rules",
        "label": "Dependency Architecture Rules",
        "description": "Enforce module boundaries and import constraints to prevent architectural drift and unwanted coupling.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stack": {
          "exampleTools": ["dependency-cruiser"],
          "exampleConfigFiles": [
            ".dependency-cruiser.cjs",
            ".dependency-cruiser.js",
            "dependency-cruiser.config.cjs"
          ],
          "notes": "Define forbidden imports, layer rules, and circular dependency bans. Run in CI as blocking check.",
          "verification": "Run 'npx depcruise --validate' or equivalent. Verify architectural rules are documented and enforced.",
          "anyOfFiles": [
            ".dependency-cruiser.cjs",
            ".dependency-cruiser.js",
            "dependency-cruiser.config.cjs",
            ".dependency-cruiser.mjs"
          ],
          "pinningNotes": "Pin dependency-cruiser version in package.json devDependencies."
        }
      },
      {
        "id": "integration-testing",
        "label": "Integration Testing",
        "description": "Test how components interact with each other and external systems, running after unit tests with more relaxed coverage thresholds.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["Jest", "Supertest", "Playwright"],
          "exampleConfigFiles": ["jest.config.*", "playwright.config.*"],
          "notes": "Use Supertest for HTTP APIs and Playwright or similar tools for end-to-end flows; keep integration suites slower but reliable.",
          "verification": "Confirm there is a separate integration or end-to-end test command or configuration and run it to verify that cross-component flows behave as expected."
        }
      },
      {
        "id": "performance-baselining",
        "label": "Performance Baselines",
        "description": "Establish performance baselines and monitor for regressions using lightweight benchmarks or audits in CI.",
        "ciHints": {
          "azure-devops": {
            "stage": "performance"
          },
          "github-actions": {
            "job": "performance"
          }
        },
        "stack": {
          "exampleTools": ["Lighthouse CI", "custom Node.js benchmarks"],
          "exampleConfigFiles": ["lighthouserc.json"],
          "notes": "Run Lighthouse CI for web apps and basic Node benchmarks on critical endpoints; schedule runs or limit to key branches to keep CI fast.",
          "verification": "Identify and run the configured performance or Lighthouse-style checks and verify that key metrics are captured and compared to documented baselines."
        }
      },
      {
        "id": "complexity-analysis",
        "label": "Complexity Analysis",
        "description": "Measure cyclomatic complexity or similar metrics to keep code maintainable, starting as a warning-only check.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["ESLint complexity rules", "SonarQube"],
          "exampleConfigFiles": [".eslintrc.*", "sonar-project.properties"],
          "notes": "Warn on overly complex functions and methods; fail CI only when new or modified code exceeds thresholds.",
          "verification": "Run the configured complexity tooling or rules (for example, ESLint complexity rules or Sonar analysis) and review any hot spots, ensuring new code does not exceed agreed thresholds."
        }
      },
      {
        "id": "accessibility-auditing",
        "label": "Accessibility Auditing",
        "description": "Run accessibility checks on web-facing components to detect critical issues and improve inclusive UX.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["axe-core", "Lighthouse accessibility audits"],
          "exampleConfigFiles": [],
          "notes": "Run accessibility checks against key pages or components in CI; fail on critical violations while treating minor issues as warnings initially.",
          "verification": "For web-facing apps, run the configured accessibility tooling (for example, axe, pa11y, or Lighthouse accessibility audits) against key pages and confirm that critical issues are resolved."
        }
      }
    ],
    "optionalEnhancements": [
      {
        "id": "observability",
        "label": "Observability (Logging & Error Handling)",
        "description": "Standardize error handling and structured logging to make debugging and production monitoring easier.",
        "ciHints": {
          "azure-devops": {
            "stage": "observability"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["Winston", "Pino"],
          "exampleConfigFiles": [],
          "notes": "Adopt structured JSON logging with correlation IDs and send logs to a centralized sink in production.",
          "verification": "Confirm that a structured logging library (such as Winston or Pino) is configured to emit JSON or key-value logs and that error handling routes important failures through this logger."
        }
      }
    ]
  }
}
