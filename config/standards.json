{
  "version": 5,
  "meta": {
    "defaultCoverageThreshold": 0.8,
    "coverageThresholdUnit": "ratio",
    "coverageThresholdDescription": "Expressed as a ratio (0-1), e.g., 0.8 = 80% coverage. Must be between 0 and 1.",
    "complexityChecks": {
      "enabledByDefault": true,
      "description": "When supported by the stack, run cyclomatic complexity or similar metrics in CI as a warning-only check initially."
    },
    "qualityGatePolicy": {
      "preferSoftFailOnLegacy": true,
      "description": "New quality checks should warn on existing code and fail CI only for violations introduced in new or changed code, to reduce friction on legacy codebases."
    },
    "migrationGuide": [
      {
        "step": 0,
        "title": "Foundation: Line Endings and Hook Entry Point",
        "description": "Configure .gitattributes for cross-platform line ending correctness and establish the canonical verify entrypoint before adding any checks. This prevents 'works locally, fails in CI' issues from day one.",
        "focusIds": [
          "gitattributes-eol",
          "canonical-verify",
          "hook-ci-parity",
          "config-authority"
        ],
        "notes": "Start here to avoid debugging cryptic CRLF failures later. Use .gitattributes as the authority for EOL (not .editorconfig). Run 'git add --renormalize .' after adding .gitattributes to fix existing files."
      },
      {
        "step": 1,
        "title": "Establish Local Safety Nets First",
        "description": "Add pre-commit hooks with secret scanning, formatting, and linting. Hooks should CHECK (not auto-fix) and scope to changed files only for speed.",
        "focusIds": [
          "pre-commit-hooks",
          "secret-scanning-precommit",
          "linting",
          "code-formatter"
        ],
        "notes": "Keep hooks fast by scoping to staged files. Use Husky as entry point calling lint-staged or pre-commit. Hooks should check, not fix, to keep developers aware of issues."
      },
      {
        "step": 2,
        "title": "Mirror Local Checks in CI with CRLF Detection",
        "description": "Introduce CI quality gates that mirror local hooks exactly. Add CRLF detection early in pipeline. Treat existing violations as warnings where possible.",
        "focusIds": [
          "crlf-detection",
          "ci-quality-gates",
          "linting",
          "code-formatter",
          "commit-linting"
        ],
        "notes": "CI must call the same verify scripts that hooks use. Add CRLF detection before other checks to fail fast on line ending issues. Use diff-based tools so only new violations break builds."
      },
      {
        "step": 3,
        "title": "Add Type Safety, Coverage, and Dependency Security",
        "description": "Enable type-checking, coverage thresholds, and dependency/vulnerability scanning with gradual enforcement.",
        "focusIds": [
          "type-checking",
          "unit-test-runner",
          "unit-test-reporter",
          "dependency-security",
          "dependency-update-automation"
        ],
        "notes": "Pin tool and runtime versions in CI and containers to avoid flaky differences across environments."
      },
      {
        "step": 4,
        "title": "Layer in Docs, Governance, and Recommended Checks",
        "description": "Add documentation standards, governance files, integration testing, performance baselines, complexity analysis, accessibility auditing, and (optionally) ML-specific practices for data-heavy Python repos.",
        "focusIds": [
          "documentation",
          "repository-governance",
          "integration-testing",
          "performance-baselining",
          "complexity-analysis",
          "accessibility-auditing"
        ],
        "notes": "Tackle recommended items in order of business value; backend-only repos can skip web-focused checks like accessibility."
      },
      {
        "step": 5,
        "title": "AI/ML Governance (If Applicable)",
        "description": "For repos using or building with generative AI, add drift detection, schema enforcement, golden contract tests, safety testing, and provenance tracking.",
        "focusIds": [
          "ai-drift-detection",
          "ai-schema-enforcement",
          "ai-golden-tests",
          "ai-safety-checks",
          "ai-provenance-tracking"
        ],
        "notes": "Skip this step if your repo has no AI/ML components. For AI-heavy repos: add nightly drift detection to catch model changes, enforce strict schemas at AI output boundaries, and log provenance for debugging 'why did AI do X?'"
      }
    ],
    "executorHints": {
      "description": "Advisory execution substrate hints. Bazel is the first supported executor; future monorepo executors may follow the same pattern.",
      "bazel": {
        "detectionRules": {
          "rootMarkers": ["MODULE.bazel", "WORKSPACE.bazel", "WORKSPACE"],
          "optionalMarkers": [".bazelrc", ".bazelversion"],
          "notes": "Detection uses repo-root markers only. Nested BUILD files do not trigger Bazel mode."
        },
        "optOut": {
          "description": "Set meta.executorHints.bazel.enabled = false in repo config to disable Bazel hints",
          "configPath": "meta.executorHints.bazel.enabled"
        },
        "targetConventions": {
          "description": "Recommended target naming (not assumed to exist). These are illustrative patterns; actual targets are repo-defined.",
          "lint": "//tools/lint:lint or bazel test //... with lint aspects",
          "format": "bazel run //tools/format:check",
          "test": "bazel test //...",
          "coverage": "bazel coverage //...",
          "build": "bazel build //..."
        },
        "ciContract": {
          "versionPinning": "Use .bazelversion file for Bazelisk",
          "configFlag": "--config=ci (define in .bazelrc)",
          "deterministicFlags": ["--nokeep_going", "--test_output=errors"],
          "remoteCache": "Optional; not required for CI"
        },
        "advisoryNotice": "bazelHints are suggestions, not required execution paths. Consumers should prefer stack-native commands unless explicitly adopting Bazel."
      }
    }
  },
  "ciSystems": ["azure-devops", "github-actions"],
  "stacks": {
    "typescript-js": {
      "label": "TypeScript / JavaScript",
      "languageFamily": "js"
    },
    "csharp-dotnet": {
      "label": "C# / .NET",
      "languageFamily": "dotnet"
    },
    "python": {
      "label": "Python",
      "languageFamily": "python"
    },
    "rust": {
      "label": "Rust",
      "languageFamily": "rust"
    },
    "go": {
      "label": "Go",
      "languageFamily": "go"
    }
  },
  "checklist": {
    "core": [
      {
        "id": "gitattributes-eol",
        "label": "Git Attributes (Line Endings)",
        "description": "Enforce line endings at the Git layer using .gitattributes. Mark text files with appropriate EOL handling (eol=lf for shell scripts, eol=auto for most files) and binary files as binary to prevent corruption. This prevents 'works locally, fails in CI' issues caused by CRLF/LF mismatches.",
        "enforcement": "required",
        "severity": "error",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection early in pipeline before other checks."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Add .gitattributes check as first step in CI job."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["git"],
            "exampleConfigFiles": [".gitattributes", ".editorconfig"],
            "notes": "Use .gitattributes as the authority for EOL; .editorconfig is supplementary for editor display. Mark *.sh, *.bash as eol=lf. After adding .gitattributes, run 'git add --renormalize .' to fix existing files. Windows contributors should set core.autocrlf=false.",
            "verification": "Run 'git ls-files --eol' and verify no unexpected CRLF in LF-only files.",
            "requiredFiles": [".gitattributes"],
            "optionalFiles": [".editorconfig"],
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(sh|bash|py)$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Verify no CRLF in shell/script files"
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["git"],
            "exampleConfigFiles": [".gitattributes", ".editorconfig"],
            "notes": "Use .gitattributes for EOL authority. Mark *.sh, *.ps1 scripts appropriately. .editorconfig drives editor behavior but .gitattributes is the source of truth for Git operations.",
            "verification": "Run 'git ls-files --eol' to check EOL consistency.",
            "requiredFiles": [".gitattributes"],
            "optionalFiles": [".editorconfig"],
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Verify no CRLF in shell scripts"
            }
          },
          "python": {
            "exampleTools": ["git"],
            "exampleConfigFiles": [".gitattributes", ".editorconfig"],
            "notes": "Python files should use LF endings for cross-platform compatibility. Mark *.py as eol=lf in .gitattributes. Shebang scripts fail with CRLF.",
            "verification": "Run 'git ls-files --eol' and verify Python files use LF.",
            "requiredFiles": [".gitattributes"],
            "optionalFiles": [".editorconfig"],
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.py$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Verify no CRLF in Python files"
            }
          },
          "rust": {
            "exampleTools": ["git"],
            "exampleConfigFiles": [".gitattributes", ".editorconfig"],
            "notes": "Mark *.rs, *.toml as text with auto EOL handling. Mark shell scripts as eol=lf. Binary files (*.exe, *.dll) should be marked as binary.",
            "verification": "Run 'git ls-files --eol' to verify EOL consistency.",
            "requiredFiles": [".gitattributes"],
            "optionalFiles": [".editorconfig"],
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Verify no CRLF in shell scripts"
            }
          },
          "go": {
            "exampleTools": ["git"],
            "exampleConfigFiles": [".gitattributes", ".editorconfig"],
            "notes": "Go files should use LF for consistency. Mark *.go as text. Shell scripts (*.sh) must use eol=lf. Binary artifacts should be marked as binary.",
            "verification": "Run 'git ls-files --eol' to verify EOL handling.",
            "requiredFiles": [".gitattributes"],
            "optionalFiles": [".editorconfig"],
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Verify no CRLF in shell scripts"
            }
          }
        }
      },
      {
        "id": "crlf-detection",
        "label": "CRLF Detection in CI",
        "description": "Fail CI early for Linux-executed files containing CRLF line endings. Shell scripts, Python files, and other interpreted files fail silently or with cryptic errors when they contain \\r characters. Detect this before running deeper CI steps.",
        "enforcement": "required",
        "severity": "error",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection as the first quality check before linting or testing."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Add CRLF detection step before main CI steps."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["file", "grep"],
            "exampleConfigFiles": [],
            "notes": "Check for CRLF in .sh, .js, .ts, .json files early in CI. Use 'file' command or grep for \\r to detect issues before they cause cryptic failures.",
            "verification": "Run 'git ls-files --eol | grep w/crlf' and verify no unexpected CRLF files.",
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(sh|js|ts|mjs|cjs)$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Detect CRLF in script files"
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["file", "grep"],
            "exampleConfigFiles": [],
            "notes": "Detect CRLF in shell scripts and CI configuration files. C# source files can tolerate CRLF but shell scripts cannot.",
            "verification": "Run CRLF detection on .sh files in CI.",
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Detect CRLF in shell scripts"
            }
          },
          "python": {
            "exampleTools": ["file", "grep"],
            "exampleConfigFiles": [],
            "notes": "Python shebang scripts fail with CRLF. Check all .py and .sh files for CRLF before running pytest or other Python tools.",
            "verification": "Run CRLF detection on Python and shell files.",
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(py|sh)$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Detect CRLF in Python/shell files"
            }
          },
          "rust": {
            "exampleTools": ["file", "grep"],
            "exampleConfigFiles": [],
            "notes": "Rust build scripts (build.rs) and shell scripts must not have CRLF. Cargo tolerates CRLF in .rs files but shell invocations fail.",
            "verification": "Run CRLF detection on shell and build scripts.",
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(sh|bash)$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Detect CRLF in shell scripts"
            }
          },
          "go": {
            "exampleTools": ["file", "grep"],
            "exampleConfigFiles": [],
            "notes": "Go source files tolerate CRLF but shell scripts and Makefiles do not. Check .sh, Makefile, and go.mod for CRLF.",
            "verification": "Run CRLF detection on shell scripts and Makefiles.",
            "machineCheck": {
              "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(sh|bash)$' && exit 1 || exit 0",
              "expectExitCode": 0,
              "description": "Detect CRLF in shell scripts"
            }
          }
        }
      },
      {
        "id": "gitignore-and-dockerignore",
        "label": "Git and Docker Ignore Files",
        "description": "Maintain proper .gitignore and .dockerignore files to prevent committing secrets, build artifacts, or unnecessary files.",
        "enforcement": "required",
        "severity": "error",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleConfigFiles": [".gitignore", ".dockerignore"],
            "notes": "Use the official github/gitignore Node template as a base and add .env*, node_modules, dist/, coverage/, *.log, npm-debug.log*, etc. .dockerignore must exclude node_modules, .git, and local build output.",
            "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
            "requiredFiles": [".gitignore"],
            "optionalFiles": [".dockerignore"]
          },
          "csharp-dotnet": {
            "exampleConfigFiles": [".gitignore", ".dockerignore"],
            "notes": "Use the official github/gitignore VisualStudio/.NET template. .dockerignore must exclude bin/, obj/, .vs/, *.user, and similar local/build artifacts.",
            "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
            "requiredFiles": [".gitignore"],
            "optionalFiles": [".dockerignore"]
          },
          "python": {
            "exampleConfigFiles": [".gitignore", ".dockerignore"],
            "notes": "Use the official github/gitignore Python template. Include **pycache**, .venv/, .pytest_cache, .env, and similar local-only files. .dockerignore must exclude .git, virtual environments, and caches.",
            "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
            "requiredFiles": [".gitignore"],
            "optionalFiles": [".dockerignore"]
          },
          "rust": {
            "exampleConfigFiles": [".gitignore", ".dockerignore"],
            "notes": "Use the official github/gitignore Rust template. Exclude target/, Cargo.lock (for libraries), *.pdb, and similar build artifacts. .dockerignore must exclude target/, .git, and local development files.",
            "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
            "requiredFiles": [".gitignore"],
            "optionalFiles": [".dockerignore"]
          },
          "go": {
            "exampleConfigFiles": [".gitignore", ".dockerignore"],
            "notes": "Use the official github/gitignore Go template. Exclude vendor/ (if not vendoring), *.exe, *.test, *.out, and IDE-specific files. .dockerignore must exclude .git and local build output.",
            "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
            "requiredFiles": [".gitignore"],
            "optionalFiles": [".dockerignore"]
          }
        }
      },
      {
        "id": "linting",
        "label": "Linting",
        "description": "Run static code linting to enforce consistency and catch common issues early.",
        "executionStage": "pre-commit",
        "scopeToChangedFiles": true,
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["eslint"],
            "exampleConfigFiles": [".eslintrc.*", "eslint.config.js"],
            "notes": "Treat new lint errors as CI failures; keep existing issues as warnings until addressed.",
            "verification": "Presence of eslint.config.js (or any .eslintrc* file) indicates linting is enforced for the repository.",
            "anyOfFiles": [
              "eslint.config.js",
              "eslint.config.mjs",
              "eslint.config.cjs",
              ".eslintrc.js",
              ".eslintrc.cjs",
              ".eslintrc.json",
              ".eslintrc.yaml",
              ".eslintrc.yml"
            ],
            "optionalFiles": [
              ".prettierrc",
              "prettier.config.js",
              "prettier.config.cjs",
              "prettier.config.json",
              "prettier.config.yaml"
            ],
            "requiredScripts": ["lint"],
            "bazelHints": {
              "commands": [
                "bazel test //... --aspects=//tools:lint.bzl%eslint_aspect --output_groups=report"
              ],
              "recommendedTargets": ["//tools/lint:lint"],
              "notes": "Example only; actual targets are repo-defined. Wrap eslint via aspect_rules_lint or a custom sh_test rule."
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["Roslyn analyzers", "StyleCop"],
            "exampleConfigFiles": [".editorconfig", "Directory.Build.props"],
            "notes": "Enable analyzers or style rules for the solution and review warnings regularly; enforce stricter rules on new code.",
            "verification": ".editorconfig must exist to drive the .NET formatting and analysis tooling.",
            "requiredFiles": [".editorconfig"],
            "optionalFiles": ["Directory.Build.props"],
            "bazelHints": {
              "commands": [
                "bazel build //... --aspects=@rules_dotnet//dotnet:analyzers.bzl%analyzer_aspect"
              ],
              "notes": "Example only; actual targets are repo-defined. Use rules_dotnet analyzer aspects for Roslyn-based linting."
            }
          },
          "python": {
            "exampleTools": ["ruff", "flake8"],
            "exampleConfigFiles": ["pyproject.toml", ".flake8", "ruff.toml"],
            "notes": "Configure a primary linter (such as ruff) and keep rules focused on catching real issues without overwhelming developers.",
            "verification": "pyproject.toml (or ruff.toml / .flake8 / setup.cfg) signals that linting tools are configured for the repository.",
            "anyOfFiles": [
              "pyproject.toml",
              "ruff.toml",
              ".flake8",
              "setup.cfg",
              "tox.ini"
            ],
            "bazelHints": {
              "commands": [
                "bazel test //...:ruff_test",
                "bazel run //tools/lint:ruff -- check ."
              ],
              "notes": "Example only; actual targets are repo-defined. Use rules_python with ruff wrapped as py_test or run target."
            }
          },
          "rust": {
            "exampleTools": ["clippy", "cargo-clippy"],
            "exampleConfigFiles": ["clippy.toml", ".clippy.toml"],
            "notes": "Use Clippy for comprehensive Rust linting. Configure via clippy.toml for project-specific rules. Treat warnings as errors in CI with -D warnings.",
            "verification": "Clippy is available via rustup component. Run 'cargo clippy' to verify linting is configured.",
            "requiredFiles": ["Cargo.toml"],
            "optionalFiles": ["clippy.toml", ".clippy.toml"],
            "bazelHints": {
              "commands": [
                "bazel build //... --aspects=@rules_rust//rust:defs.bzl%clippy_aspect --output_groups=clippy_checks"
              ],
              "notes": "Example only; actual targets are repo-defined. rules_rust includes clippy_aspect for Bazel-native Clippy linting."
            }
          },
          "go": {
            "exampleTools": ["golangci-lint", "staticcheck"],
            "exampleConfigFiles": [".golangci.yml", ".golangci.yaml"],
            "notes": "Use golangci-lint as the primary linter aggregator. Configure enabled linters in .golangci.yml for consistent team-wide enforcement.",
            "verification": ".golangci.yml or .golangci.yaml indicates linting is configured. Run 'golangci-lint run' to verify.",
            "requiredFiles": ["go.mod"],
            "optionalFiles": [".golangci.yml", ".golangci.yaml"],
            "bazelHints": {
              "commands": [
                "bazel test //... --@io_bazel_rules_go//go/config:nogo=@//:nogo"
              ],
              "notes": "Use nogo for static analysis via rules_go. Configure nogo target with desired analyzers."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "unit-test-runner",
        "label": "Unit Test Runner",
        "description": "Provide a deterministic unit test framework with a single command to run all tests.",
        "executionStage": "pre-push",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["jest"],
            "exampleConfigFiles": ["jest.config.*"],
            "notes": "Keep unit tests fast and deterministic; move slow or flaky tests into integration or E2E suites.",
            "verification": "Test framework configuration is present; test script is defined in package.json.",
            "optionalFiles": [
              "jest.config.js",
              "jest.config.ts",
              "vitest.config.js",
              "vitest.config.ts"
            ],
            "requiredScripts": ["test"],
            "bazelHints": {
              "commands": ["bazel test //..."],
              "notes": "Bazel discovers and runs all test targets. Use rules_js for Jest/Vitest integration."
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["xUnit", "NUnit", "MSTest"],
            "exampleConfigFiles": ["*.Tests.csproj"],
            "notes": "Group unit tests into dedicated test projects and keep them independent from external services.",
            "verification": "Test projects are present in the solution; test configuration is defined.",
            "optionalFiles": ["*.Tests.csproj"],
            "bazelHints": {
              "commands": ["bazel test //..."],
              "notes": "Use rules_dotnet to define test targets for xUnit/NUnit/MSTest projects."
            }
          },
          "python": {
            "exampleTools": ["pytest"],
            "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
            "notes": "Organize unit tests under a tests/ directory and avoid real network or database calls in this layer.",
            "verification": "Test framework configuration is present; tests/ directory or pytest configuration exists.",
            "optionalFiles": ["pytest.ini", "pyproject.toml", "tests/"],
            "bazelHints": {
              "commands": ["bazel test //..."],
              "notes": "Example only; actual targets are repo-defined. Use rules_python py_test for pytest-based tests."
            }
          },
          "rust": {
            "exampleTools": ["cargo test"],
            "exampleConfigFiles": ["Cargo.toml"],
            "notes": "Use cargo test as the built-in test runner. Organize tests in tests/ directory for integration tests and inline #[test] functions for unit tests.",
            "verification": "Run 'cargo test' to verify the test suite is configured and passing.",
            "requiredFiles": ["Cargo.toml"],
            "optionalFiles": ["tests/"],
            "bazelHints": {
              "commands": ["bazel test //..."],
              "notes": "rules_rust rust_test targets run cargo test under Bazel's hermetic environment."
            }
          },
          "go": {
            "exampleTools": ["go test"],
            "exampleConfigFiles": ["go.mod"],
            "notes": "Use 'go test ./...' to run all tests. Place test files alongside source files with _test.go suffix. Keep unit tests fast and isolated.",
            "verification": "Run 'go test ./...' to verify the test suite is configured and passing.",
            "requiredFiles": ["go.mod"],
            "optionalFiles": [],
            "bazelHints": {
              "commands": ["bazel test //..."],
              "notes": "rules_go go_test targets wrap 'go test' with Bazel's caching and hermeticity."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "containerization",
        "label": "Containerization (Docker / Docker Compose)",
        "description": "Provide a Dockerfile and, if applicable, a docker-compose file for local dev and CI parity.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
            "notes": "Use multi-stage builds and pin Node.js and base image versions in the Dockerfile to match CI (e.g., node:22-alpine).",
            "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
            "requiredFiles": ["Dockerfile"],
            "optionalFiles": ["docker-compose.yml"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
            "notes": "Use multi-stage builds for .NET publish output and pin the SDK/runtime image versions to match CI.",
            "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
            "requiredFiles": ["Dockerfile"],
            "optionalFiles": ["docker-compose.yml"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
            "notes": "Choose a slim Python base image, pin the version, and clearly document how to start the service in a container.",
            "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
            "requiredFiles": ["Dockerfile"],
            "optionalFiles": ["docker-compose.yml"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
            "notes": "Use multi-stage builds: builder stage with rust:alpine for compiling, then copy binary to distroless or alpine for minimal runtime image. Pin Rust version via rust-toolchain.toml.",
            "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
            "requiredFiles": ["Dockerfile"],
            "optionalFiles": ["docker-compose.yml"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
            "notes": "Use multi-stage builds: builder stage with golang:alpine, then copy binary to scratch or distroless for minimal runtime. Set CGO_ENABLED=0 for static binaries.",
            "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
            "requiredFiles": ["Dockerfile"],
            "optionalFiles": ["docker-compose.yml"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "semantic-versioning",
        "label": "Semantic Versioning",
        "description": "Use MAJOR.MINOR.PATCH versioning with clear rules and automated changelog generation based on commit history. Maintain a single canonical version source (for example, package.json or VERSION) that all release artifacts use.",
        "executionStage": "release",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          },
          "github-actions": {
            "job": "release"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["semantic-release", "standard-version"],
            "exampleConfigFiles": [
              ".releaserc",
              "package.json",
              "CHANGELOG.md"
            ],
            "notes": "Automate version bumping and changelog generation from Conventional Commits using semantic-release or standard-version. Keep package.json (or a VERSION file) as the single canonical version source and have CI publish npm/GitHub/Docker artifacts from that same version. Protect release branches and ensure release tooling only runs there.",
            "verification": "Check that the canonical version field follows SemVer, and trigger the configured release workflow (for example, a dry run of semantic-release or standard-version) to confirm it generates the expected next version, updates package.json or VERSION, and creates/updates CHANGELOG.md with commit-based entries.",
            "requiredFiles": ["package.json"],
            "optionalFiles": ["VERSION", "CHANGELOG.md"],
            "requiredScripts": ["release"]
          },
          "csharp-dotnet": {
            "exampleTools": ["GitVersion"],
            "exampleConfigFiles": [
              "GitVersion.yml",
              "*.csproj",
              "CHANGELOG.md"
            ],
            "notes": "Use GitVersion (or Directory.Build.props) as the single canonical version source, computed from git history, and feed it into assembly/package versions. Configure CI to auto-generate or update CHANGELOG.md from commit messages and git tags. Integrate with the release pipeline to version assemblies, NuGet packages, and publish GitHub releases from the same version.",
            "verification": "Check that versioning is driven by a SemVer-aware tool (for example, GitVersion) and verify that running the release/versioning step locally or in CI produces the expected version metadata, updates project files, and generates changelog entries from commit history.",
            "requiredFiles": ["*.csproj"],
            "optionalFiles": [
              "GitVersion.yml",
              "Directory.Build.props",
              "CHANGELOG.md"
            ],
            "requiredScripts": ["release"]
          },
          "python": {
            "exampleTools": ["bumpversion", "setuptools_scm", "towncrier"],
            "exampleConfigFiles": [
              "pyproject.toml",
              "setup.cfg",
              "CHANGELOG.md"
            ],
            "notes": "Automate version bumping and changelog generation using setuptools_scm (git-tag based) or bumpversion with towncrier for changelog fragments. Keep pyproject.toml (or VERSION) as the single canonical version source, and have CI publish GitHub/PyPI/Docker artifacts from that same version.",
            "verification": "Check that the canonical version in pyproject.toml or VERSION follows SemVer and verify that the configured tool (for example, setuptools_scm or bumpversion) computes or bumps the version and generates changelog entries from commit history or fragments.",
            "requiredFiles": ["pyproject.toml"],
            "optionalFiles": ["VERSION", "CHANGELOG.md"],
            "requiredScripts": ["release"]
          },
          "rust": {
            "exampleTools": ["cargo-release", "semantic-release"],
            "exampleConfigFiles": ["Cargo.toml", "CHANGELOG.md"],
            "notes": "Version is defined in Cargo.toml as the canonical source. Use cargo-release or semantic-release-cargo for automated versioning and GitHub release publishing, and follow Conventional Commits for changelog generation.",
            "verification": "Check that Cargo.toml version follows SemVer and verify changelog generation from commit history.",
            "requiredFiles": ["Cargo.toml"],
            "optionalFiles": ["CHANGELOG.md"],
            "requiredScripts": ["release"]
          },
          "go": {
            "exampleTools": ["goreleaser", "semantic-release"],
            "exampleConfigFiles": [".goreleaser.yml", "CHANGELOG.md"],
            "notes": "Go uses git tags (v1.2.3) as the canonical version source. Use goreleaser for automated releases with changelog generation and publish GitHub/Docker artifacts from the same tag.",
            "verification": "Check that git tags follow vMAJOR.MINOR.PATCH format and goreleaser or similar tooling generates releases and changelogs.",
            "optionalFiles": [".goreleaser.yml", "CHANGELOG.md"],
            "requiredScripts": ["release"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "version-guard",
        "label": "Version Guard (Automated Releases)",
        "description": "If semantic-release or automated versioning is enabled, block manual edits to canonical version fields in pull requests. Enforce a CI guard (and optional pre-push hook) that fails when version lines change outside the release workflow.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run the version guard in PR validation jobs before merge."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Run the version guard in PR workflows against the base ref."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["semantic-release", "git"],
            "exampleConfigFiles": [
              "scripts/check-version-unchanged.sh",
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Add a CI step that runs scripts/check-version-unchanged.sh against the PR base ref. This blocks manual edits to package.json version when semantic-release owns versioning. Optionally wire the same script into a pre-push hook for fast feedback.",
            "verification": "Run the guard with the PR base ref (for example, origin/main) and confirm it fails when package.json version changes.",
            "requiredFiles": ["package.json"],
            "optionalFiles": ["VERSION"]
          },
          "csharp-dotnet": {
            "exampleTools": ["GitVersion", "git"],
            "exampleConfigFiles": [
              "scripts/check-version-unchanged.sh",
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "When GitVersion or similar tooling computes versions, block manual edits to Directory.Build.props or *.csproj version fields via the version guard. Allow changes only in release automation.",
            "verification": "Run the guard and confirm it fails when <Version> or <VersionPrefix> changes in props/csproj files.",
            "optionalFiles": ["Directory.Build.props", "*.csproj", "VERSION"]
          },
          "python": {
            "exampleTools": ["semantic-release", "git"],
            "exampleConfigFiles": [
              "scripts/check-version-unchanged.sh",
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Block manual edits to version fields in pyproject.toml or setup.cfg when automated release tooling computes versions from commit history.",
            "verification": "Run the guard and confirm it fails when version lines change in pyproject.toml or setup.cfg.",
            "requiredFiles": ["pyproject.toml"],
            "optionalFiles": ["setup.cfg", "setup.py", "VERSION"]
          },
          "rust": {
            "exampleTools": ["cargo-release", "semantic-release", "git"],
            "exampleConfigFiles": [
              "scripts/check-version-unchanged.sh",
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "When using cargo-release or semantic-release-cargo, guard against manual edits to Cargo.toml version fields in PRs.",
            "verification": "Run the guard and confirm it fails when Cargo.toml version changes.",
            "requiredFiles": ["Cargo.toml"]
          },
          "go": {
            "exampleTools": ["goreleaser", "git"],
            "exampleConfigFiles": [
              "scripts/check-version-unchanged.sh",
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Go versioning is tag-driven; only enable the guard if you keep a VERSION file or embed version constants in code. The guard should ensure those fields are not edited manually in PRs.",
            "verification": "Run the guard and confirm it fails when VERSION or version constants change outside release automation.",
            "optionalFiles": ["VERSION"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "unified-release-workflow",
        "label": "Unified Release Workflow",
        "description": "Use a single CI release pipeline that publishes all artifacts (GitHub releases, packages, containers) from the same canonical version source.",
        "executionStage": "release",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          },
          "github-actions": {
            "job": "release"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [
              "semantic-release",
              "changesets",
              "npm publish",
              "docker buildx"
            ],
            "exampleConfigFiles": [
              ".github/workflows/release.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Release workflow must publish npm packages, GitHub releases, and Docker images from the same canonical version (package.json or VERSION). Avoid separate manual steps or ad-hoc scripts for different artifacts.",
            "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
            "requiredScripts": ["release"],
            "optionalFiles": ["CHANGELOG.md", "VERSION"]
          },
          "csharp-dotnet": {
            "exampleTools": ["GitVersion", "dotnet pack", "dotnet nuget push"],
            "exampleConfigFiles": [
              "azure-pipelines.yml",
              ".github/workflows/release.yml"
            ],
            "notes": "Use a single release pipeline to publish NuGet packages, GitHub releases, and Docker images from the canonical version source (GitVersion or Directory.Build.props).",
            "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
            "requiredScripts": ["release"],
            "optionalFiles": ["GitVersion.yml", "Directory.Build.props"]
          },
          "python": {
            "exampleTools": [
              "setuptools_scm",
              "twine",
              "build",
              "docker buildx"
            ],
            "exampleConfigFiles": [
              ".github/workflows/release.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use a single release pipeline to publish PyPI packages, GitHub releases, and Docker images from the canonical version source (pyproject.toml or VERSION).",
            "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
            "requiredScripts": ["release"],
            "optionalFiles": ["CHANGELOG.md", "VERSION"]
          },
          "rust": {
            "exampleTools": ["cargo-release", "cargo publish", "docker buildx"],
            "exampleConfigFiles": [
              ".github/workflows/release.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use a single release pipeline to publish crates.io packages, GitHub releases, and Docker images from the Cargo.toml version.",
            "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
            "requiredScripts": ["release"],
            "optionalFiles": ["CHANGELOG.md"]
          },
          "go": {
            "exampleTools": ["goreleaser", "docker buildx"],
            "exampleConfigFiles": [
              ".github/workflows/release.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use a single release pipeline (goreleaser or equivalent) to publish GitHub releases and Docker images from the same git tag.",
            "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
            "requiredScripts": ["release"],
            "optionalFiles": [".goreleaser.yml", "CHANGELOG.md"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "release-hook-bypass",
        "label": "Release Hook Bypass",
        "description": "Release automation must bypass local developer hooks (HUSKY=0, --no-verify) and rely solely on CI gates for validation. This ensures idempotent, reproducible releases that don't fail due to hook environment differences.",
        "executionStage": "release",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "release",
            "notes": "Set HUSKY=0 or equivalent in release pipeline to disable hooks."
          },
          "github-actions": {
            "job": "release",
            "notes": "Set HUSKY=0 or equivalent in release job to disable hooks."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["semantic-release", "husky"],
            "exampleConfigFiles": [".github/workflows/release.yml"],
            "notes": "In release workflows, set HUSKY=0 environment variable to disable husky hooks. Release commits from semantic-release should bypass commitlint since they're generated. CI gates already validated the code.",
            "verification": "Check release workflow for HUSKY=0 or --no-verify flags.",
            "machineCheck": {
              "command": "grep -r 'HUSKY=0\\|--no-verify' .github/workflows/ || echo 'WARNING: No hook bypass in release workflow'",
              "expectExitCode": 0,
              "description": "Verify release workflows disable hooks"
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["GitVersion"],
            "exampleConfigFiles": [
              "azure-pipelines.yml",
              ".github/workflows/release.yml"
            ],
            "notes": "Release pipelines should skip local hooks. If using Lefthook, set LEFTHOOK=0. Rely on CI gates for all validation.",
            "verification": "Check release pipeline for hook bypass configuration."
          },
          "python": {
            "exampleTools": ["semantic-release", "bumpversion"],
            "exampleConfigFiles": [".github/workflows/release.yml"],
            "notes": "Set PRE_COMMIT_ALLOW_NO_CONFIG=1 or SKIP=all to bypass pre-commit hooks in release automation. CI gates already validated.",
            "verification": "Check release workflow for pre-commit bypass."
          },
          "rust": {
            "exampleTools": ["cargo-release"],
            "exampleConfigFiles": [".github/workflows/release.yml"],
            "notes": "Use --no-verify with git commands in release scripts. If using pre-commit, set SKIP=all.",
            "verification": "Check release workflow for hook bypass."
          },
          "go": {
            "exampleTools": ["goreleaser"],
            "exampleConfigFiles": [
              ".goreleaser.yml",
              ".github/workflows/release.yml"
            ],
            "notes": "Goreleaser handles releases without invoking local hooks. Ensure any git operations use --no-verify.",
            "verification": "Check release workflow for hook bypass configuration."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "commit-linting",
        "label": "Commit Linting",
        "description": "Enforce structured commit messages such as Conventional Commits via commit-msg hooks and CI. This is required for deterministic versioning and changelog generation.",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [
              "@commitlint/cli",
              "@commitlint/config-conventional"
            ],
            "exampleConfigFiles": ["commitlint.config.*"],
            "notes": "Enforce Conventional Commits via commit-msg hooks (e.g., Husky) and a CI job so versioning/changelog automation is deterministic.",
            "verification": "Create a test commit using the documented convention and ensure the commit message passes both local commit-msg hooks and CI checks.",
            "anyOfFiles": [
              "commitlint.config.js",
              "commitlint.config.cjs",
              "commitlint.config.mjs",
              "commitlint.config.json"
            ],
            "requiredScripts": ["commitlint"]
          },
          "csharp-dotnet": {
            "exampleTools": ["commitlint", "commitizen"],
            "exampleConfigFiles": ["commitlint.config.*", ".cz.toml"],
            "notes": "Document your Conventional Commit convention and enforce it via commit-msg hooks and CI so release tooling can compute versions deterministically.",
            "verification": "Create a test commit following the documented convention and confirm that commit-msg hooks and CI checks accept it.",
            "anyOfFiles": [
              "commitlint.config.js",
              "commitlint.config.cjs",
              "commitlint.config.mjs",
              "commitlint.config.json",
              ".cz.toml"
            ],
            "requiredScripts": ["commitlint"]
          },
          "python": {
            "exampleTools": ["commitizen"],
            "exampleConfigFiles": [".cz.toml", "pyproject.toml"],
            "notes": "Standardize Conventional Commits using commitizen or commitlint with commit-msg hooks plus CI so changelog generation is deterministic.",
            "verification": "Use the configured commit helper or hooks to create a test commit and confirm that non-conforming messages are rejected locally and in CI.",
            "anyOfFiles": [
              ".cz.toml",
              "commitlint.config.js",
              "commitlint.config.cjs",
              "commitlint.config.mjs",
              "commitlint.config.json"
            ],
            "requiredScripts": ["commitlint"]
          },
          "rust": {
            "exampleTools": ["commitlint", "commitizen"],
            "exampleConfigFiles": ["commitlint.config.js", ".cz.toml"],
            "notes": "Use commitlint with husky or pre-commit for enforcing Conventional Commits and add a CI check to keep version/changelog automation deterministic.",
            "verification": "Test that non-conforming commit messages are rejected by the configured hooks and CI check.",
            "anyOfFiles": [
              "commitlint.config.js",
              "commitlint.config.cjs",
              "commitlint.config.mjs",
              "commitlint.config.json",
              ".cz.toml"
            ],
            "requiredScripts": ["commitlint"]
          },
          "go": {
            "exampleTools": ["commitlint", "commitizen"],
            "exampleConfigFiles": ["commitlint.config.js", ".cz.toml"],
            "notes": "Use commitlint with commit-msg or pre-commit hooks plus a CI check. Conventional Commits keep goreleaser changelog generation deterministic.",
            "verification": "Test that non-conforming commit messages are rejected by the configured hooks and CI check.",
            "anyOfFiles": [
              "commitlint.config.js",
              "commitlint.config.cjs",
              "commitlint.config.mjs",
              "commitlint.config.json",
              ".cz.toml"
            ],
            "requiredScripts": ["commitlint"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "unit-test-reporter",
        "label": "Unit Test Reporter / Coverage",
        "description": "Generate readable unit test and coverage reports and enforce a minimum coverage threshold (around 80%) for new or changed code.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["jest", "nyc"],
            "exampleConfigFiles": ["jest.config.*"],
            "notes": "Collect coverage in lcov or similar format; use diff coverage so legacy gaps are visible but non-blocking.",
            "verification": "Run the unit tests with coverage enabled and confirm that a coverage report is produced and that the configured threshold (around 80%) is enforced for new changes.",
            "bazelHints": {
              "commands": ["bazel coverage //..."],
              "notes": "Bazel coverage collects coverage data from all test targets. Use --combined_report=lcov for aggregated reports."
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["coverlet", "ReportGenerator"],
            "exampleConfigFiles": ["*.csproj"],
            "notes": "Enable coverage collection for test projects and publish reports in a human-friendly format from CI.",
            "verification": "Run the test suite with coverage enabled (for example, using coverlet or a similar tool) and verify that coverage reports are generated and used in CI to monitor thresholds.",
            "bazelHints": {
              "commands": ["bazel coverage //..."],
              "notes": "Use rules_dotnet with coverage instrumentation enabled."
            }
          },
          "python": {
            "exampleTools": ["pytest", "pytest-cov", "coverage.py"],
            "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
            "notes": "Configure coverage reporting for your test suite and surface summary metrics in CI.",
            "verification": "Run the unit tests with coverage (for example, pytest with pytest-cov) and confirm that coverage reports are generated and referenced in CI to enforce or track thresholds.",
            "bazelHints": {
              "commands": ["bazel coverage //..."],
              "notes": "Use rules_python py_test with coverage instrumentation. Combine with --combined_report=lcov."
            }
          },
          "rust": {
            "exampleTools": ["cargo-tarpaulin", "llvm-cov", "grcov"],
            "exampleConfigFiles": ["Cargo.toml"],
            "notes": "Use cargo-tarpaulin or llvm-cov for code coverage. Generate lcov or cobertura reports for CI integration.",
            "verification": "Run 'cargo tarpaulin' or equivalent and verify coverage reports are generated and thresholds enforced.",
            "bazelHints": {
              "commands": ["bazel coverage //..."],
              "notes": "Bazel coverage with rules_rust requires LLVM instrumentation. May need additional toolchain configuration."
            }
          },
          "go": {
            "exampleTools": ["go test -cover", "go tool cover"],
            "exampleConfigFiles": ["go.mod"],
            "notes": "Use 'go test -coverprofile=coverage.out ./...' for coverage. Generate HTML or integrate with codecov/coveralls.",
            "verification": "Run 'go test -cover ./...' and verify coverage reports are produced and thresholds monitored.",
            "bazelHints": {
              "commands": ["bazel coverage //..."],
              "notes": "rules_go supports coverage via bazel coverage. Use --combined_report=lcov for aggregated output."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "ci-quality-gates",
        "label": "CI Quality Gates",
        "description": "Single CI pipeline that runs linting, formatting, type checking, tests, coverage, build, and containerization.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".github/workflows/*",
              "azure-pipelines.yml"
            ],
            "notes": "Expose a single npm script (e.g., `npm run ci`) that mirrors the CI pipeline so contributors can reproduce failures locally.",
            "verification": "Open the CI configuration and verify there is a job or stage that runs linting, type checking, tests, build, and any required container checks before merging to main.",
            "bazelHints": {
              "commands": ["bazel build //...", "bazel test //..."],
              "notes": "Replace npm run ci with Bazel commands. All quality gates run as Bazel targets."
            }
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".github/workflows/*",
              "azure-pipelines.yml"
            ],
            "notes": "Ensure CI runs analyzers, tests, build, and packaging or container checks before changes can be merged.",
            "verification": "Open the CI configuration and verify there is a job or stage that runs analyzers, tests, build, and any required packaging or container checks before merging to main.",
            "bazelHints": {
              "commands": ["bazel build //...", "bazel test //..."],
              "notes": "Bazel handles all analysis, testing, and packaging via defined targets."
            }
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".github/workflows/*",
              "azure-pipelines.yml"
            ],
            "notes": "Ensure CI runs linting, type checking (if used), tests, and packaging or container checks for Python services before merging.",
            "verification": "Open the CI configuration and verify there is a job or stage that runs linting, type checking (if used), tests, and any packaging or container checks before merging to main.",
            "bazelHints": {
              "commands": ["bazel build //...", "bazel test //..."],
              "notes": "Bazel py_binary and py_test targets replace traditional Python tooling."
            }
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".github/workflows/*",
              "azure-pipelines.yml"
            ],
            "notes": "Use 'cargo clippy', 'cargo test', 'cargo build --release' as quality gates. Consider cargo-deny for dependency auditing.",
            "verification": "Verify CI runs cargo clippy, cargo test, and cargo build before merging to main.",
            "bazelHints": {
              "commands": ["bazel build //...", "bazel test //..."],
              "notes": "rules_rust provides rust_library, rust_test, and clippy_aspect for complete CI."
            }
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".github/workflows/*",
              "azure-pipelines.yml"
            ],
            "notes": "Run 'golangci-lint run', 'go test ./...', 'go build' as quality gates. Use govulncheck for security scanning.",
            "verification": "Verify CI runs golangci-lint, go test, and go build before merging to main.",
            "bazelHints": {
              "commands": ["bazel build //...", "bazel test //..."],
              "notes": "rules_go go_binary and go_test targets provide hermetic builds and tests."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "code-formatter",
        "label": "Code Formatter",
        "description": "Automatic code formatting to maintain a consistent style across all contributors.",
        "executionStage": "pre-commit",
        "scopeToChangedFiles": true,
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["prettier"],
            "exampleConfigFiles": [".prettierrc.*", ".prettierignore"],
            "notes": "Run Prettier in check mode in CI; auto-fix locally via pre-commit hooks or editor integration.",
            "verification": "Run the formatter in check mode (for example, `npm run format:check`) and confirm it reports clean formatting on committed code and auto-fixes as expected locally.",
            "bazelHints": {
              "commands": [
                "bazel run //tools/format:check",
                "bazel test //...:format_test"
              ],
              "notes": "Wrap Prettier as a run target for formatting checks. Use aspect_rules_lint for format aspects."
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet format"],
            "exampleConfigFiles": [".editorconfig"],
            "notes": "Use .editorconfig and dotnet-format to keep C# style consistent across contributors.",
            "verification": "Run the configured formatter or code style enforcement (for example, `dotnet format`) and confirm that code in the repository conforms to the defined rules.",
            "bazelHints": {
              "commands": [
                "bazel run //tools/format:dotnet_format -- --verify-no-changes"
              ],
              "notes": "Wrap dotnet format as a Bazel run target."
            }
          },
          "python": {
            "exampleTools": ["black"],
            "exampleConfigFiles": ["pyproject.toml"],
            "notes": "Use black (or an equivalent opinionated formatter) and treat its output as the single source of truth for code style.",
            "verification": "Run the configured formatter (for example, `black .` or `black --check .`) and confirm it reports clean formatting on committed code and auto-fixes as expected locally.",
            "bazelHints": {
              "commands": ["bazel run //tools/format:black -- --check ."],
              "notes": "Wrap black as a py_binary run target for format checking."
            }
          },
          "rust": {
            "exampleTools": ["rustfmt"],
            "exampleConfigFiles": ["rustfmt.toml", ".rustfmt.toml"],
            "notes": "Use rustfmt (via 'cargo fmt') as the standard formatter. Configure via rustfmt.toml. Run 'cargo fmt --check' in CI.",
            "verification": "Run 'cargo fmt --check' and confirm it reports clean formatting. Use 'cargo fmt' to auto-fix.",
            "bazelHints": {
              "commands": [
                "bazel build //... --aspects=@rules_rust//rust:defs.bzl%rustfmt_aspect --output_groups=rustfmt_checks"
              ],
              "notes": "rules_rust includes rustfmt_aspect for Bazel-native format checking."
            }
          },
          "go": {
            "exampleTools": ["gofmt", "goimports"],
            "exampleConfigFiles": [],
            "notes": "Use gofmt (built-in) for formatting. goimports extends gofmt with import organization. Formatting is enforced by convention.",
            "verification": "Run 'gofmt -d .' or 'goimports -d .' and confirm no output indicates clean formatting.",
            "bazelHints": {
              "commands": ["bazel run @go_sdk//:bin/gofmt -- -d ."],
              "notes": "Run gofmt via the Bazel-managed Go SDK for hermetic formatting checks."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "pre-commit-hooks",
        "label": "Pre-Commit Hooks",
        "description": "Use git hooks to run linting, formatting, and commit linting before changes are committed. Hooks should CHECK by default (not auto-fix), be fast, and scope to changed files only. Use a single entry hook mechanism (e.g., Husky as entry point calling pre-commit or lint-staged).",
        "executionStage": "pre-commit",
        "scopeToChangedFiles": true,
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Hooks and CI must invoke identical verification commands. Use npm run verify or equivalent."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Hooks and CI must invoke identical verification commands. Use npm run verify or equivalent."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["husky", "lint-staged"],
            "exampleConfigFiles": [
              ".husky/",
              "package.json",
              "lint-staged.config.js"
            ],
            "notes": "Use Husky as the entry hook mechanism calling lint-staged. Hooks should CHECK (--check flags) not auto-fix to keep developers aware of issues. Scope to staged files only for speed. Invoke hooks through the repo toolchain (npx) not global installs to ensure environment pinning. Never let hook enforcement drift from CI.",
            "verification": "Run 'npm run verify' (or equivalent) and confirm the same checks run in both hooks and CI."
          },
          "csharp-dotnet": {
            "exampleTools": ["Lefthook", "husky.net"],
            "exampleConfigFiles": ["lefthook.yml", ".husky/"],
            "notes": "Configure Lefthook or husky.net to run formatting checks (not auto-fix) on staged files. Hooks should be deterministic and environment-pinned via global.json SDK version.",
            "verification": "Inspect hook configuration and confirm checks run in verify mode, not auto-fix mode."
          },
          "python": {
            "exampleTools": ["pre-commit"],
            "exampleConfigFiles": [".pre-commit-config.yaml"],
            "notes": "Use pre-commit framework as both entry and executor. Pin hook versions in .pre-commit-config.yaml for determinism. Hooks should run checks (ruff check, black --check) not auto-fix. Run pre-commit install to set up hooks.",
            "verification": "Inspect .pre-commit-config.yaml and confirm hooks use check/verify flags, not auto-fix."
          },
          "rust": {
            "exampleTools": ["pre-commit", "cargo-husky"],
            "exampleConfigFiles": [".pre-commit-config.yaml"],
            "notes": "Use pre-commit with rust hooks for 'cargo fmt --check' and 'cargo clippy' on staged files. Pin rust-toolchain.toml for determinism across environments.",
            "verification": "Confirm hooks run cargo fmt --check (not cargo fmt) and cargo clippy before commits."
          },
          "go": {
            "exampleTools": ["pre-commit", "lefthook"],
            "exampleConfigFiles": [".pre-commit-config.yaml", "lefthook.yml"],
            "notes": "Use pre-commit or lefthook with go hooks for 'gofmt -d' (check mode) and golangci-lint. Pin Go version in go.mod and .go-version for determinism.",
            "verification": "Confirm hooks run format checks (not auto-fix) and golangci-lint before commits."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "hook-ci-parity",
        "label": "Hook/CI Parity",
        "description": "Local hooks and CI must invoke identical verification commands to prevent 'works locally, fails in CI' issues. Use a single canonical verify entrypoint (e.g., npm run verify) that both hooks and CI call.",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the same verify script that hooks use locally."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI should call the same verify script that hooks use locally."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["npm scripts"],
            "exampleConfigFiles": ["package.json"],
            "notes": "Define a 'verify' script in package.json that runs all checks (lint, format:check, typecheck). Both .husky/pre-commit and CI should call 'npm run verify'. Never add checks to CI that don't run locally.",
            "verification": "Compare hook commands with CI commands and confirm they invoke the same scripts.",
            "requiredScripts": ["verify"]
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet CLI", "make"],
            "exampleConfigFiles": ["Makefile", "Directory.Build.props"],
            "notes": "Define a verify target (make verify or dotnet cake verify) that both hooks and CI invoke. Keep verification logic in one place.",
            "verification": "Compare hook commands with CI commands and confirm they invoke the same targets."
          },
          "python": {
            "exampleTools": ["make", "tox", "nox"],
            "exampleConfigFiles": ["Makefile", "tox.ini", "noxfile.py"],
            "notes": "Define a verify target (make verify, tox -e lint, or nox -s lint) that both pre-commit and CI invoke. Pin tool versions in pyproject.toml.",
            "verification": "Compare hook commands with CI commands and confirm they invoke the same targets."
          },
          "rust": {
            "exampleTools": ["cargo", "make"],
            "exampleConfigFiles": ["Makefile", "Cargo.toml"],
            "notes": "Define a verify target (make verify or cargo make verify) that runs fmt --check, clippy, and test. Both hooks and CI should use this target.",
            "verification": "Compare hook commands with CI commands and confirm they invoke the same cargo commands."
          },
          "go": {
            "exampleTools": ["make", "mage"],
            "exampleConfigFiles": ["Makefile", "magefile.go"],
            "notes": "Define a verify target (make verify) that runs go vet, golangci-lint, and go test. Both hooks and CI should use this target.",
            "verification": "Compare hook commands with CI commands and confirm they invoke the same make targets."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "secret-scanning-precommit",
        "label": "Pre-commit Secret Scanning",
        "description": "Scan staged diffs for credentials, API keys, and secrets before they reach the remote repository. Catch secrets at commit time rather than after they're pushed.",
        "executionStage": "pre-commit",
        "scopeToChangedFiles": true,
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Also run secret scanning in CI as a safety net for commits that bypassed hooks."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Enable GitHub secret scanning and also run gitleaks in CI."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["gitleaks", "detect-secrets", "trufflehog"],
            "exampleConfigFiles": [".gitleaks.toml", ".secrets.baseline"],
            "notes": "Add gitleaks or detect-secrets to pre-commit hooks. Scan only staged changes for speed. Configure allowlists for false positives in .gitleaks.toml.",
            "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
          },
          "csharp-dotnet": {
            "exampleTools": ["gitleaks", "detect-secrets"],
            "exampleConfigFiles": [".gitleaks.toml"],
            "notes": "Add gitleaks to pre-commit hooks via Lefthook. Scan staged changes before commits.",
            "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
          },
          "python": {
            "exampleTools": ["detect-secrets", "gitleaks"],
            "exampleConfigFiles": [
              ".pre-commit-config.yaml",
              ".secrets.baseline"
            ],
            "notes": "Add detect-secrets or gitleaks to .pre-commit-config.yaml. Use detect-secrets audit to manage baselines.",
            "verification": "Run 'detect-secrets scan' or 'gitleaks protect' and verify scanning works."
          },
          "rust": {
            "exampleTools": ["gitleaks"],
            "exampleConfigFiles": [".gitleaks.toml", ".pre-commit-config.yaml"],
            "notes": "Add gitleaks to pre-commit hooks. Configure Rust-specific patterns if needed.",
            "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
          },
          "go": {
            "exampleTools": ["gitleaks", "trufflehog"],
            "exampleConfigFiles": [".gitleaks.toml", ".pre-commit-config.yaml"],
            "notes": "Add gitleaks to pre-commit hooks. Scan staged changes only for speed.",
            "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "type-checking",
        "label": "Type Checking",
        "description": "Use static type checking to catch errors before runtime and enforce strictness on new code. For JS/TS stacks, require a TypeScript-first policy with strict mode and a CI typecheck step; allow JSDoc/checkJs migration for legacy JS.",
        "executionStage": "pre-push",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["TypeScript compiler (tsc)"],
            "exampleConfigFiles": ["tsconfig.json"],
            "notes": "Adopt a TypeScript-first policy. Require tsconfig.json with strict mode enabled ('strict': true) and enforce `npm run typecheck` (or equivalent) in CI. For legacy JS, allow JSDoc + `checkJs` or staged migration with `allowJs` while incrementally increasing coverage.",
            "verification": "tsconfig.json exists with strict mode enabled and CI runs the typecheck script; legacy JS modules use JSDoc/checkJs or allowJs as an explicit migration path.",
            "requiredFiles": ["tsconfig.json"],
            "requiredScripts": ["typecheck"],
            "bazelHints": {
              "commands": ["bazel build //..."],
              "notes": "TypeScript type errors surface during bazel build with rules_ts. No separate typecheck step needed."
            }
          },
          "csharp-dotnet": {
            "exampleTools": ["Roslyn analyzers"],
            "exampleConfigFiles": [
              ".editorconfig",
              "Directory.Build.props",
              "*.csproj"
            ],
            "notes": "Enable nullable reference types and relevant analyzers to catch type and nullability issues at compile time. C# project files (*.csproj) indicate the presence of projects that can be type-checked.",
            "verification": ".editorconfig must exist; Directory.Build.props is optional for shared build configuration.",
            "requiredFiles": [".editorconfig"],
            "optionalFiles": ["Directory.Build.props"],
            "bazelHints": {
              "commands": ["bazel build //..."],
              "notes": "Example only; actual targets are repo-defined. C# type errors surface during bazel build with rules_dotnet."
            }
          },
          "python": {
            "exampleTools": ["mypy"],
            "exampleConfigFiles": ["mypy.ini", "pyproject.toml"],
            "notes": "Adopt gradual typing with type hints and mypy, focusing first on critical modules and new code paths.",
            "verification": "pyproject.toml (or mypy.ini) signals that mypy configuration is available for the repository.",
            "requiredFiles": ["pyproject.toml"],
            "optionalFiles": ["mypy.ini"],
            "requiredScripts": ["typecheck"],
            "bazelHints": {
              "commands": [
                "bazel test //...:mypy_test",
                "bazel run //tools/typecheck:mypy"
              ],
              "notes": "Example only; actual targets are repo-defined. Wrap mypy as a py_test or run target."
            }
          },
          "rust": {
            "exampleTools": ["rustc (built-in)"],
            "exampleConfigFiles": ["Cargo.toml"],
            "notes": "Rust has compile-time type checking built into the language. The borrow checker enforces memory safety. No additional tooling needed for type safety.",
            "verification": "Run 'cargo check' or 'cargo build' to verify type correctness. All Rust code is type-checked by default.",
            "requiredFiles": ["Cargo.toml"],
            "bazelHints": {
              "commands": ["bazel build //..."],
              "notes": "Rust type checking is inherent to compilation. bazel build with rules_rust enforces type safety."
            }
          },
          "go": {
            "exampleTools": ["go vet", "staticcheck"],
            "exampleConfigFiles": ["go.mod"],
            "notes": "Go has compile-time type checking built in. Use 'go vet' for additional static analysis. staticcheck provides enhanced type-related checks.",
            "verification": "Run 'go build ./...' to verify type correctness. Use 'go vet ./...' for additional static analysis.",
            "requiredFiles": ["go.mod"],
            "bazelHints": {
              "commands": ["bazel build //..."],
              "notes": "Go type checking is inherent to compilation. bazel build with rules_go enforces type safety."
            }
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "dependency-security",
        "label": "Dependency Management & Vulnerability Scanning",
        "description": "Lock dependencies and scan regularly for known vulnerabilities; fail CI on newly introduced high-severity issues.",
        "executionStage": "pre-push",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["npm audit", "Snyk"],
            "exampleConfigFiles": [
              "package-lock.json",
              "pnpm-lock.yaml",
              "yarn.lock"
            ],
            "notes": "Require a lockfile for reproducible installs and pin Node.js/tooling versions; block merges on new high-severity vulnerabilities.",
            "verification": "Dependency lockfile is present; security scanning is configured in CI or project tooling.",
            "optionalFiles": [
              "package-lock.json",
              "pnpm-lock.yaml",
              "yarn.lock"
            ]
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet list package --vulnerable"],
            "exampleConfigFiles": ["packages.lock.json", "*.csproj"],
            "notes": "Enable package lock files and use vulnerability scanning to track and remediate high-risk dependencies.",
            "verification": "Dependency lockfile or package reference is present; security scanning is configured.",
            "optionalFiles": ["packages.lock.json"]
          },
          "python": {
            "exampleTools": ["pip-audit", "safety"],
            "exampleConfigFiles": [
              "requirements.txt",
              "Pipfile.lock",
              "poetry.lock"
            ],
            "notes": "Pin dependency versions and routinely scan for vulnerabilities, prioritizing fixes for critical and high-severity issues.",
            "verification": "Dependency lockfile is present; security scanning is configured in CI or project tooling.",
            "optionalFiles": ["requirements.txt", "Pipfile.lock", "poetry.lock"]
          },
          "rust": {
            "exampleTools": ["cargo-audit", "cargo-deny"],
            "exampleConfigFiles": ["Cargo.lock", "deny.toml"],
            "notes": "Use cargo-audit for vulnerability scanning or cargo-deny for comprehensive dependency checking (licenses, advisories, bans). Cargo.lock locks versions.",
            "verification": "Cargo.lock is present; run 'cargo audit' or 'cargo deny check' to verify security scanning.",
            "optionalFiles": ["deny.toml"],
            "anyOfFiles": ["Cargo.lock"],
            "pinningNotes": "Required for binaries/services; optional for libraries (add to .gitignore for libs). See https://doc.rust-lang.org/cargo/faq.html#why-have-cargolock-in-version-control"
          },
          "go": {
            "exampleTools": ["govulncheck", "nancy"],
            "exampleConfigFiles": ["go.sum"],
            "notes": "Use govulncheck (official Go tool) for vulnerability scanning. go.sum locks dependency checksums for reproducible builds.",
            "verification": "go.sum is present; run 'govulncheck ./...' to verify security scanning.",
            "requiredFiles": ["go.sum"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "deterministic-builds",
        "label": "Deterministic & Hermetic Builds",
        "description": "Ensure builds are reproducible by pinning dependencies, base images, and tool/runtime versions. Avoid network/time variance and fail when lockfiles drift.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [
              "npm ci",
              "pnpm install --frozen-lockfile",
              "yarn --immutable"
            ],
            "exampleConfigFiles": [
              "package-lock.json",
              "pnpm-lock.yaml",
              "yarn.lock"
            ],
            "notes": "Require a lockfile and pinned Node/tool versions (.nvmrc or .tool-versions). Pin base images in Dockerfiles and avoid non-deterministic install flags.",
            "verification": "Lockfile is present and CI uses a frozen/immutable install. Dockerfiles reference pinned base images.",
            "anyOfFiles": ["package-lock.json", "pnpm-lock.yaml", "yarn.lock"],
            "optionalFiles": [".nvmrc", ".tool-versions"]
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet restore --locked-mode"],
            "exampleConfigFiles": ["packages.lock.json", "global.json"],
            "notes": "Enable packages.lock.json and use locked restore. Pin SDK versions via global.json and pin base images in Dockerfiles.",
            "verification": "packages.lock.json or equivalent lock files exist and restore runs in locked mode. SDK versions are pinned.",
            "optionalFiles": ["packages.lock.json", "global.json"]
          },
          "python": {
            "exampleTools": ["pip-tools", "poetry", "uv"],
            "exampleConfigFiles": [
              "requirements.txt",
              "poetry.lock",
              "Pipfile.lock"
            ],
            "notes": "Use pinned lockfiles (requirements.txt or poetry.lock) and pin Python version (.python-version or tool-versions). Avoid non-deterministic installs in CI.",
            "verification": "Lockfile is present and CI installs with pinned versions only. Python runtime is pinned.",
            "anyOfFiles": ["requirements.txt", "poetry.lock", "Pipfile.lock"],
            "optionalFiles": [".python-version", ".tool-versions"]
          },
          "rust": {
            "exampleTools": ["cargo build --locked"],
            "exampleConfigFiles": ["Cargo.lock", "rust-toolchain.toml"],
            "notes": "Commit Cargo.lock for binaries/services and pin Rust versions with rust-toolchain.toml. Use --locked in CI.",
            "verification": "Cargo.lock is present and CI uses --locked. Rust toolchain is pinned.",
            "requiredFiles": ["Cargo.lock"],
            "optionalFiles": ["rust-toolchain.toml"]
          },
          "go": {
            "exampleTools": ["go env -w GOPROXY=off", "go mod download"],
            "exampleConfigFiles": ["go.sum", "go.mod", ".go-version"],
            "notes": "Use go.sum for deterministic module versions and pin Go versions (go.mod + .go-version). Avoid network variance by caching modules and pinning proxies.",
            "verification": "go.sum is present and builds use pinned Go versions; module downloads are cached.",
            "requiredFiles": ["go.sum"],
            "optionalFiles": [".go-version"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "provenance-security",
        "label": "Provenance & Security Metadata",
        "description": "Produce SBOMs or provenance metadata, enable secret/code scanning, and sign tags or commits for critical repos.",
        "executionStage": "release",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "security"
          },
          "github-actions": {
            "job": "security"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [
              "syft",
              "cyclonedx-npm",
              "codeql",
              "gitleaks",
              "cosign"
            ],
            "exampleConfigFiles": [
              ".github/workflows/codeql.yml",
              ".github/workflows/provenance.yml"
            ],
            "notes": "Generate SBOM/provenance for npm and container artifacts, enable secret scanning, and sign tags/commits for protected branches.",
            "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
            "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
          },
          "csharp-dotnet": {
            "exampleTools": ["sbom-tool", "codeql", "gitleaks", "cosign"],
            "exampleConfigFiles": [
              ".github/workflows/codeql.yml",
              ".github/workflows/provenance.yml"
            ],
            "notes": "Generate SBOM/provenance for NuGet and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
            "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
            "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
          },
          "python": {
            "exampleTools": [
              "cyclonedx-python",
              "syft",
              "codeql",
              "gitleaks",
              "cosign"
            ],
            "exampleConfigFiles": [
              ".github/workflows/codeql.yml",
              ".github/workflows/provenance.yml"
            ],
            "notes": "Generate SBOM/provenance for PyPI and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
            "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
            "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
          },
          "rust": {
            "exampleTools": [
              "cargo-cyclonedx",
              "syft",
              "codeql",
              "gitleaks",
              "cosign"
            ],
            "exampleConfigFiles": [
              ".github/workflows/codeql.yml",
              ".github/workflows/provenance.yml"
            ],
            "notes": "Generate SBOM/provenance for crates and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
            "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
            "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
          },
          "go": {
            "exampleTools": [
              "syft",
              "cyclonedx-gomod",
              "codeql",
              "gitleaks",
              "cosign"
            ],
            "exampleConfigFiles": [
              ".github/workflows/codeql.yml",
              ".github/workflows/provenance.yml"
            ],
            "notes": "Generate SBOM/provenance for Go binaries and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
            "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
            "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "ci-templates-automation",
        "label": "CI Templates & Automation",
        "description": "Adopt standard CI templates and config samples to scale across repositories, minimizing bespoke pipeline logic.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [
              "GitHub Actions reusable workflows",
              "Azure DevOps templates"
            ],
            "exampleConfigFiles": [
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use shared CI templates for lint/test/build/release stages and keep repo-specific overrides minimal.",
            "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
            "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
            "requiredScripts": ["ci"]
          },
          "csharp-dotnet": {
            "exampleTools": [
              "GitHub Actions reusable workflows",
              "Azure DevOps templates"
            ],
            "exampleConfigFiles": [
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use shared CI templates for build/test/pack/release stages to standardize across .NET repos.",
            "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
            "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
            "requiredScripts": ["ci"]
          },
          "python": {
            "exampleTools": [
              "GitHub Actions reusable workflows",
              "Azure DevOps templates"
            ],
            "exampleConfigFiles": [
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use shared CI templates for lint/test/typecheck/release stages to standardize across Python repos.",
            "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
            "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
            "requiredScripts": ["ci"]
          },
          "rust": {
            "exampleTools": [
              "GitHub Actions reusable workflows",
              "Azure DevOps templates"
            ],
            "exampleConfigFiles": [
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use shared CI templates for build/test/release stages to standardize across Rust repos.",
            "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
            "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
            "requiredScripts": ["ci"]
          },
          "go": {
            "exampleTools": [
              "GitHub Actions reusable workflows",
              "Azure DevOps templates"
            ],
            "exampleConfigFiles": [
              ".github/workflows/ci.yml",
              "azure-pipelines.yml"
            ],
            "notes": "Use shared CI templates for build/test/release stages to standardize across Go repos.",
            "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
            "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
            "requiredScripts": ["ci"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "runtime-version",
        "label": "Runtime Version Specification",
        "description": "Specify required runtime/engine versions in package manifests to ensure environment stability and prevent version-related issues across development teams.",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": ["package.json"],
            "notes": "Specify the 'engines' field in package.json to define the required Node.js version (e.g., \"engines\": { \"node\": \">=18.0.0\" }). This helps prevent environment-related bugs and ensures all developers use compatible Node.js versions.",
            "verification": "package.json must contain an 'engines' field specifying the required Node.js version.",
            "requiredFiles": ["package.json"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": ["*.csproj", "global.json"],
            "notes": "Specify TargetFramework in .csproj files (e.g., <TargetFramework>net8.0</TargetFramework>) and optionally use global.json to pin the SDK version (e.g., { \"sdk\": { \"version\": \"8.0.100\" } }) for consistent builds across the team.",
            "verification": ".csproj files must specify TargetFramework; global.json is recommended to pin SDK version.",
            "optionalFiles": ["global.json"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "pyproject.toml",
              "setup.py",
              ".python-version"
            ],
            "notes": "Specify python_requires in pyproject.toml (e.g., requires-python = \">=3.9\") or setup.py (e.g., python_requires='>=3.9'). Consider adding .python-version for pyenv users to automatically switch to the correct Python version.",
            "verification": "pyproject.toml or setup.py must specify python_requires; .python-version is recommended for local development.",
            "requiredFiles": ["pyproject.toml"],
            "optionalFiles": [".python-version"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": ["rust-toolchain.toml", "rust-toolchain"],
            "notes": "Use rust-toolchain.toml to pin the Rust version (e.g., channel = 'stable' or specific version '1.75.0'). This ensures consistent builds across the team via rustup.",
            "verification": "rust-toolchain.toml or rust-toolchain file specifies the required Rust version.",
            "optionalFiles": ["rust-toolchain.toml", "rust-toolchain"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": ["go.mod", ".go-version"],
            "notes": "Specify 'go' directive in go.mod (e.g., go 1.21) to set minimum Go version. Consider .go-version for goenv users.",
            "verification": "go.mod must contain 'go' directive specifying minimum version; .go-version is optional for local development.",
            "requiredFiles": ["go.mod"],
            "optionalFiles": [".go-version"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "documentation",
        "label": "Documentation Standards",
        "description": "Maintain a comprehensive README and, where applicable, auto-generated API docs to support onboarding and maintainability.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "docs"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["JSDoc", "TypeDoc"],
            "exampleConfigFiles": ["README.md", "docs/"],
            "notes": "README should describe setup, scripts, and architecture; generate API docs from TypeScript types and JSDoc where helpful.",
            "verification": "README.md is present in the repository root; docs/ directory or documentation tooling configuration exists if applicable.",
            "requiredFiles": ["README.md"],
            "optionalFiles": ["docs/", "typedoc.json"]
          },
          "csharp-dotnet": {
            "exampleTools": ["DocFX"],
            "exampleConfigFiles": ["README.md", "docfx.json"],
            "notes": "Keep README and API docs in sync with the solution structure and public surface area.",
            "verification": "README.md is present in the repository root; docs/ directory or DocFX configuration exists if applicable.",
            "requiredFiles": ["README.md"],
            "optionalFiles": ["docs/", "docfx.json"]
          },
          "python": {
            "exampleTools": ["Sphinx", "MkDocs"],
            "exampleConfigFiles": ["README.md", "docs/"],
            "notes": "Ensure README explains environment setup and core commands, and generate API docs from docstrings where appropriate.",
            "verification": "README.md is present in the repository root; docs/ directory or documentation tooling configuration exists if applicable.",
            "requiredFiles": ["README.md"],
            "optionalFiles": ["docs/", "mkdocs.yml"]
          },
          "rust": {
            "exampleTools": ["rustdoc", "mdBook"],
            "exampleConfigFiles": ["README.md", "docs/"],
            "notes": "Use rustdoc (via 'cargo doc') for API documentation from doc comments. Consider mdBook for user guides and tutorials.",
            "verification": "README.md is present; run 'cargo doc' to generate API docs.",
            "requiredFiles": ["README.md"],
            "optionalFiles": ["docs/", "book.toml"]
          },
          "go": {
            "exampleTools": ["godoc", "pkgsite"],
            "exampleConfigFiles": ["README.md", "docs/"],
            "notes": "Use godoc or pkgsite for API documentation from code comments. Follow Go documentation conventions.",
            "verification": "README.md is present; documentation comments exist in exported functions/types.",
            "requiredFiles": ["README.md"],
            "optionalFiles": ["docs/"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "repository-governance",
        "label": "Repository Governance",
        "description": "Include standard governance files (LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md), branch protection rules, and review standards to define legal, ethical, and workflow expectations.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "LICENSE",
              "CODE_OF_CONDUCT.md",
              "CONTRIBUTING.md"
            ],
            "notes": "Use an SPDX license identifier in package.json and describe review expectations, tests, and docs requirements in CONTRIBUTING.md.",
            "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
            "requiredFiles": ["LICENSE"],
            "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "LICENSE",
              "CODE_OF_CONDUCT.md",
              "CONTRIBUTING.md"
            ],
            "notes": "Document contribution expectations and ensure legal and code-of-conduct policies are easy to find.",
            "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
            "requiredFiles": ["LICENSE"],
            "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "LICENSE",
              "CODE_OF_CONDUCT.md",
              "CONTRIBUTING.md"
            ],
            "notes": "Spell out contributor responsibilities for tests, documentation, and review so expectations are clear for Python-focused teams.",
            "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
            "requiredFiles": ["LICENSE"],
            "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "LICENSE",
              "CODE_OF_CONDUCT.md",
              "CONTRIBUTING.md"
            ],
            "notes": "Include license in Cargo.toml metadata. Document cargo workspace conventions and testing requirements in CONTRIBUTING.md.",
            "verification": "LICENSE file is present; CODE_OF_CONDUCT.md and CONTRIBUTING.md provide contribution guidance.",
            "requiredFiles": ["LICENSE"],
            "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": [
              "LICENSE",
              "CODE_OF_CONDUCT.md",
              "CONTRIBUTING.md"
            ],
            "notes": "Include license identifier in go.mod comments if needed. Document Go module conventions and testing requirements in CONTRIBUTING.md.",
            "verification": "LICENSE file is present; CODE_OF_CONDUCT.md and CONTRIBUTING.md provide contribution guidance.",
            "requiredFiles": ["LICENSE"],
            "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "canonical-verify",
        "label": "Canonical Verify Entrypoint",
        "description": "Provide one canonical 'verify' command per repository/stack that all stages call with appropriate flags. This prevents duplication, drift, and ensures consistency between local development and CI.",
        "executionStage": "pre-commit",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the canonical verify command, not duplicate check logic."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI should call the canonical verify command, not duplicate check logic."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["npm scripts"],
            "exampleConfigFiles": ["package.json"],
            "notes": "Define 'npm run verify' that runs lint, format:check, typecheck, and test. Pre-commit hooks call 'npm run verify:quick' (lint + format only). CI calls 'npm run verify' (full suite). Never duplicate verification logic across multiple scripts.",
            "verification": "package.json contains a 'verify' script that orchestrates all checks.",
            "requiredScripts": ["verify"]
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet CLI", "make", "cake"],
            "exampleConfigFiles": ["Makefile", "build.cake"],
            "notes": "Define 'make verify' or 'dotnet cake verify' that runs all checks. Both hooks and CI use this single entrypoint with stage-appropriate flags.",
            "verification": "Makefile or build script contains a 'verify' target."
          },
          "python": {
            "exampleTools": ["make", "tox", "nox"],
            "exampleConfigFiles": ["Makefile", "tox.ini", "noxfile.py"],
            "notes": "Define 'make verify' or 'tox -e verify' that runs ruff, black --check, mypy, and pytest. All stages use this entrypoint.",
            "verification": "Makefile or tox.ini contains a 'verify' target/environment."
          },
          "rust": {
            "exampleTools": ["cargo", "make", "cargo-make"],
            "exampleConfigFiles": ["Makefile", "Makefile.toml"],
            "notes": "Define 'make verify' or 'cargo make verify' that runs fmt --check, clippy, and test. Both hooks and CI use this entrypoint.",
            "verification": "Makefile or Makefile.toml contains a 'verify' task."
          },
          "go": {
            "exampleTools": ["make", "mage"],
            "exampleConfigFiles": ["Makefile", "magefile.go"],
            "notes": "Define 'make verify' that runs go vet, golangci-lint, and go test. All stages use this single entrypoint.",
            "verification": "Makefile contains a 'verify' target."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "config-authority",
        "label": "Config File Authority Rules",
        "description": "Each configuration rule must live in exactly one authoritative config file. Avoid duplication across .editorconfig, linter configs, and CI definitions. Document which file is authoritative for each concern.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Ensure CI reads from authoritative configs, not duplicated settings."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Ensure CI reads from authoritative configs, not duplicated settings."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".gitattributes",
              ".editorconfig",
              "eslint.config.js",
              "tsconfig.json"
            ],
            "notes": "Authority mapping: .gitattributes for EOL (Git layer), .editorconfig for editor display, eslint.config.js for lint rules, tsconfig.json for TS compiler options, prettier for formatting. Never duplicate rules across files.",
            "verification": "Review configs and confirm no rule is defined in multiple places with potential for drift."
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".gitattributes",
              ".editorconfig",
              "Directory.Build.props"
            ],
            "notes": "Authority mapping: .gitattributes for EOL, .editorconfig for formatting rules, Directory.Build.props for shared build settings. Roslyn analyzers read from .editorconfig.",
            "verification": "Review configs and confirm no rule is duplicated across files."
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".gitattributes",
              "pyproject.toml",
              ".editorconfig"
            ],
            "notes": "Authority mapping: .gitattributes for EOL, pyproject.toml for all tool configs (ruff, black, mypy, pytest). Avoid separate tool configs (.flake8, setup.cfg) when pyproject.toml can hold them.",
            "verification": "Review configs and confirm pyproject.toml is the single source for tool settings."
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": [
              ".gitattributes",
              "Cargo.toml",
              "rustfmt.toml",
              "clippy.toml"
            ],
            "notes": "Authority mapping: .gitattributes for EOL, Cargo.toml for project config, rustfmt.toml for formatting, clippy.toml for linting. Each concern has one file.",
            "verification": "Review configs and confirm no rules are duplicated across files."
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": [".gitattributes", "go.mod", ".golangci.yml"],
            "notes": "Authority mapping: .gitattributes for EOL, go.mod for module config and Go version, .golangci.yml for all linting rules. Keep lint config consolidated in one file.",
            "verification": "Review configs and confirm .golangci.yml is the single source for lint rules."
          }
        },
        "enforcement": "required",
        "severity": "error"
      },
      {
        "id": "explicit-skip-paths",
        "label": "Explicit Skip Paths",
        "description": "Encode path exclusions and skip rules deterministically in config files, not through ad-hoc human judgment. Make it clear which paths are excluded from checks and why.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should read skip paths from config files, not hardcode them in pipeline."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI should read skip paths from config files, not hardcode them in pipeline."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["eslint", "prettier"],
            "exampleConfigFiles": [
              ".eslintignore",
              ".prettierignore",
              "eslint.config.js"
            ],
            "notes": "Define ignores in eslint.config.js (ignores array) and .prettierignore. Document why each path is excluded (generated code, vendor, etc.). Avoid ad-hoc --ignore-path flags in scripts.",
            "verification": "Review ignore configs and confirm all exclusions are documented and intentional."
          },
          "csharp-dotnet": {
            "exampleTools": ["dotnet format", "Roslyn"],
            "exampleConfigFiles": [".editorconfig"],
            "notes": "Use .editorconfig file globs to exclude generated code from analysis. Document exclusions with comments.",
            "verification": "Review .editorconfig and confirm exclusions are explicit and documented."
          },
          "python": {
            "exampleTools": ["ruff", "black", "mypy"],
            "exampleConfigFiles": ["pyproject.toml"],
            "notes": "Define exclude patterns in pyproject.toml [tool.ruff], [tool.black], [tool.mypy] sections. Document why each path is excluded. Avoid runtime --exclude flags.",
            "verification": "Review pyproject.toml and confirm all exclusions are defined there, not in scripts."
          },
          "rust": {
            "exampleTools": ["rustfmt", "clippy"],
            "exampleConfigFiles": ["rustfmt.toml", ".clippy.toml"],
            "notes": "Use #[rustfmt::skip] or #[allow(clippy::*)] sparingly and document why. For directory-level exclusions, use Cargo.toml workspace exclude.",
            "verification": "Search for skip annotations and confirm each is documented."
          },
          "go": {
            "exampleTools": ["golangci-lint"],
            "exampleConfigFiles": [".golangci.yml"],
            "notes": "Define skip-dirs and skip-files in .golangci.yml. Use //nolint comments sparingly and always include justification (//nolint:errcheck // reason).",
            "verification": "Review .golangci.yml and confirm skip paths are explicit and documented."
          }
        },
        "enforcement": "required",
        "severity": "error"
      }
    ],
    "recommended": [
      {
        "id": "dependency-update-automation",
        "label": "Dependency Update Automation",
        "description": "Automate dependency updates using Renovate or Dependabot to keep dependencies current and reduce security exposure window.",
        "executionStage": "nightly",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["renovate", "dependabot"],
            "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
            "notes": "Renovate supports GHA + AzDO (self-hosted or Mend Renovate App). Dependabot is GitHub-native only. For AzDO: use Renovate via self-hosted runner, Docker container job, or Mend's hosted service.",
            "verification": "Check for renovate.json (or .renovaterc.json) OR .github/dependabot.yml. Verify dependency update PRs are being created.",
            "anyOfFiles": [
              "renovate.json",
              ".renovaterc.json",
              "renovate.json5",
              ".renovaterc.json5",
              ".github/dependabot.yml"
            ],
            "pinningNotes": "Pin Renovate Docker image version in AzDO pipelines for determinism."
          },
          "csharp-dotnet": {
            "exampleTools": ["renovate", "dependabot"],
            "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
            "notes": "Both support NuGet packages. Renovate has better Central Package Management (Directory.Packages.props) support. For AzDO: use self-hosted Renovate runner.",
            "verification": "Check for renovate.json OR .github/dependabot.yml. Verify NuGet update PRs.",
            "anyOfFiles": [
              "renovate.json",
              ".renovaterc.json",
              ".github/dependabot.yml"
            ],
            "pinningNotes": "Pin Renovate version in pipeline definition."
          },
          "python": {
            "exampleTools": ["renovate", "dependabot"],
            "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
            "notes": "Renovate supports pyproject.toml, requirements.txt, Pipfile, poetry.lock. For AzDO: self-hosted Renovate or schedule-triggered pipeline.",
            "verification": "Check for renovate.json OR .github/dependabot.yml. Verify Python dependency PRs.",
            "anyOfFiles": [
              "renovate.json",
              ".renovaterc.json",
              ".github/dependabot.yml"
            ],
            "pinningNotes": "Use requirements.txt with pinned versions or poetry.lock for deterministic installs."
          },
          "rust": {
            "exampleTools": ["renovate", "dependabot"],
            "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
            "notes": "Both support Cargo.toml/Cargo.lock. Works with cargo workspaces. Security scanning is covered by dependency-security (cargo-audit/cargo-deny).",
            "verification": "Check for renovate.json OR .github/dependabot.yml. Verify Cargo dependency PRs.",
            "anyOfFiles": [
              "renovate.json",
              ".renovaterc.json",
              ".github/dependabot.yml"
            ]
          },
          "go": {
            "exampleTools": ["renovate", "dependabot"],
            "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
            "notes": "Both support go.mod/go.sum. Renovate handles replace directives better. Security scanning is covered by dependency-security (govulncheck).",
            "verification": "Check for renovate.json OR .github/dependabot.yml. Verify Go module PRs.",
            "anyOfFiles": [
              "renovate.json",
              ".renovaterc.json",
              ".github/dependabot.yml"
            ]
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "dependency-architecture-rules",
        "label": "Dependency Architecture Rules",
        "description": "Enforce module boundaries and import constraints to prevent architectural drift and unwanted coupling.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          },
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["dependency-cruiser"],
            "exampleConfigFiles": [
              ".dependency-cruiser.cjs",
              ".dependency-cruiser.js",
              "dependency-cruiser.config.cjs"
            ],
            "notes": "Define forbidden imports, layer rules, and circular dependency bans. Run in CI as blocking check.",
            "verification": "Run 'npx depcruise --validate' or equivalent. Verify architectural rules are documented and enforced.",
            "anyOfFiles": [
              ".dependency-cruiser.cjs",
              ".dependency-cruiser.js",
              "dependency-cruiser.config.cjs",
              ".dependency-cruiser.mjs"
            ],
            "pinningNotes": "Pin dependency-cruiser version in package.json devDependencies."
          },
          "csharp-dotnet": {
            "exampleTools": ["NsDepCop", "ArchUnitNET"],
            "exampleConfigFiles": [
              "NsDepCop.config.nsdepcop",
              "ArchitectureTests.cs"
            ],
            "notes": "NsDepCop enforces namespace dependency rules via config file. ArchUnitNET uses test code for architectural assertions.",
            "verification": "Build fails on namespace violations, or architecture tests run as part of test suite.",
            "optionalFiles": ["NsDepCop.config.nsdepcop"]
          },
          "python": {
            "exampleTools": ["import-linter", "pydeps"],
            "exampleConfigFiles": ["pyproject.toml", ".importlinter"],
            "notes": "Configure [tool.importlinter] in pyproject.toml OR use standalone .importlinter file. pydeps is visualization-only.",
            "verification": "Run 'lint-imports' successfully. Config must exist in pyproject.toml [tool.importlinter] section OR .importlinter file.",
            "optionalFiles": ["pyproject.toml", ".importlinter"]
          },
          "rust": {
            "exampleTools": ["cargo-deny"],
            "exampleConfigFiles": ["deny.toml"],
            "notes": "cargo-deny's [bans] section enforces dependency graph rules (deny specific crates, wildcards). Extend existing config if using for security scanning.",
            "verification": "Run 'cargo deny check bans' to verify dependency constraints.",
            "optionalFiles": ["deny.toml"]
          },
          "go": {
            "exampleTools": ["depaware", "go-mod-check"],
            "exampleConfigFiles": [],
            "notes": "Go's module system is simpler. Use internal/ packages for visibility. depaware provides transitive dep analysis. Standard practice: 'go mod tidy && git diff --exit-code go.mod go.sum'.",
            "verification": "Run 'go mod verify' and 'go mod tidy' with diff check in CI."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "integration-testing",
        "label": "Integration Testing",
        "description": "Test how components interact with each other and external systems, running after unit tests with more relaxed coverage thresholds.",
        "executionStage": "ci-main",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["Jest", "Supertest", "Playwright"],
            "exampleConfigFiles": ["jest.config.*", "playwright.config.*"],
            "notes": "Use Supertest for HTTP APIs and Playwright or similar tools for end-to-end flows; keep integration suites slower but reliable.",
            "verification": "Confirm there is a separate integration or end-to-end test command or configuration and run it to verify that cross-component flows behave as expected."
          },
          "csharp-dotnet": {
            "exampleTools": ["xUnit", "NUnit", "MSTest"],
            "exampleConfigFiles": ["*.IntegrationTests.csproj"],
            "notes": "Create dedicated integration test projects that exercise real infrastructure or service boundaries where appropriate.",
            "verification": "Confirm there is a test project or configuration dedicated to integration or API tests and run it to verify external or cross-service interactions behave as expected."
          },
          "python": {
            "exampleTools": ["pytest"],
            "exampleConfigFiles": ["tests/integration/"],
            "notes": "Separate integration tests from unit tests, using fixtures to handle databases, services, or other external systems.",
            "verification": "Confirm there is a separate integration or API test suite (for example, a dedicated tests/integration directory) and run it to verify interactions with databases, services, or external systems."
          },
          "rust": {
            "exampleTools": ["cargo test"],
            "exampleConfigFiles": ["tests/"],
            "notes": "Use the tests/ directory for integration tests. Use #[ignore] attribute for slow tests and run with 'cargo test -- --ignored'.",
            "verification": "Confirm tests/ directory contains integration tests and run 'cargo test' to verify cross-component flows."
          },
          "go": {
            "exampleTools": ["go test"],
            "exampleConfigFiles": ["*_test.go"],
            "notes": "Use build tags (//go:build integration) or separate test directories for integration tests. Run with 'go test -tags=integration ./...'.",
            "verification": "Confirm integration tests exist and run 'go test -tags=integration ./...' to verify."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "performance-baselining",
        "label": "Performance Baselines",
        "description": "Establish performance baselines and monitor for regressions using lightweight benchmarks or audits in CI.",
        "executionStage": "nightly",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "performance"
          },
          "github-actions": {
            "job": "performance"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["Lighthouse CI", "custom Node.js benchmarks"],
            "exampleConfigFiles": ["lighthouserc.json"],
            "notes": "Run Lighthouse CI for web apps and basic Node benchmarks on critical endpoints; schedule runs or limit to key branches to keep CI fast.",
            "verification": "Identify and run the configured performance or Lighthouse-style checks and verify that key metrics are captured and compared to documented baselines."
          },
          "csharp-dotnet": {
            "exampleTools": ["BenchmarkDotNet"],
            "exampleConfigFiles": ["*.csproj"],
            "notes": "Use BenchmarkDotNet or similar to track performance of critical methods or endpoints over time.",
            "verification": "Identify and run the configured performance or benchmarking suite (for example, BenchmarkDotNet) and review the output to ensure it is tracked against historical or target values."
          },
          "python": {
            "exampleTools": ["pytest-benchmark", "cProfile"],
            "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
            "notes": "Use simple benchmarks or profiling runs to characterize bottlenecks and watch for regressions in critical workflows.",
            "verification": "Identify and run the configured performance checks or benchmarks (for example, pytest-benchmark or cProfile-based scripts) and confirm that their results are recorded and compared over time."
          },
          "rust": {
            "exampleTools": ["criterion", "cargo bench"],
            "exampleConfigFiles": ["benches/"],
            "notes": "Use criterion for statistical benchmarking. Create benches/ directory for benchmark files. Track results over time in CI.",
            "verification": "Run 'cargo bench' and verify benchmark results are captured and compared against baselines."
          },
          "go": {
            "exampleTools": ["go test -bench", "benchstat"],
            "exampleConfigFiles": ["*_test.go"],
            "notes": "Use 'go test -bench=. ./...' for benchmarks. Use benchstat to compare results across runs.",
            "verification": "Run 'go test -bench=. ./...' and verify benchmark results are tracked over time."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "complexity-analysis",
        "label": "Complexity Analysis",
        "description": "Measure cyclomatic complexity or similar metrics to keep code maintainable, starting as a warning-only check.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["ESLint complexity rules", "SonarQube"],
            "exampleConfigFiles": [".eslintrc.*", "sonar-project.properties"],
            "notes": "Warn on overly complex functions and methods; fail CI only when new or modified code exceeds thresholds.",
            "verification": "Run the configured complexity tooling or rules (for example, ESLint complexity rules or Sonar analysis) and review any hot spots, ensuring new code does not exceed agreed thresholds."
          },
          "csharp-dotnet": {
            "exampleTools": ["SonarQube", "Visual Studio code metrics"],
            "exampleConfigFiles": ["sonar-project.properties"],
            "notes": "Use code metrics or Sonar analysis to flag overly complex methods and refactor them over time.",
            "verification": "Run the configured code metrics or Sonar analysis and review complexity reports for key modules, ensuring that new or changed code stays within acceptable limits."
          },
          "python": {
            "exampleTools": ["radon"],
            "exampleConfigFiles": ["radon.cfg"],
            "notes": "Use radon or similar tools to track complexity of Python functions and keep new code within acceptable limits.",
            "verification": "Run the configured complexity tool (for example, radon) on the codebase and review the report to ensure new or heavily changed functions are not excessively complex."
          },
          "rust": {
            "exampleTools": ["clippy", "cargo-geiger"],
            "exampleConfigFiles": ["clippy.toml"],
            "notes": "Clippy includes cognitive complexity warnings. Use cargo-geiger for unsafe code metrics. Configure thresholds in clippy.toml.",
            "verification": "Run 'cargo clippy' and review complexity-related warnings. Ensure new code stays within acceptable limits."
          },
          "go": {
            "exampleTools": ["gocyclo", "golangci-lint"],
            "exampleConfigFiles": [".golangci.yml"],
            "notes": "Use gocyclo or golangci-lint's gocyclo linter to measure cyclomatic complexity. Configure threshold in .golangci.yml.",
            "verification": "Run 'gocyclo' or 'golangci-lint run' and review complexity reports, ensuring new code doesn't exceed thresholds."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "accessibility-auditing",
        "label": "Accessibility Auditing",
        "description": "Run accessibility checks on web-facing components to detect critical issues and improve inclusive UX.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["axe-core", "Lighthouse accessibility audits"],
            "exampleConfigFiles": [],
            "notes": "Run accessibility checks against key pages or components in CI; fail on critical violations while treating minor issues as warnings initially.",
            "verification": "For web-facing apps, run the configured accessibility tooling (for example, axe, pa11y, or Lighthouse accessibility audits) against key pages and confirm that critical issues are resolved."
          },
          "csharp-dotnet": {
            "exampleTools": ["axe-core", "Accessibility Insights"],
            "exampleConfigFiles": [],
            "notes": "Apply accessibility tooling to ASP.NET or Blazor front-ends and review issues alongside functional testing.",
            "verification": "For web-facing apps, run the configured accessibility checks or tools against your main UI endpoints and confirm that blocking accessibility issues are addressed."
          },
          "python": {
            "exampleTools": ["pa11y"],
            "exampleConfigFiles": [],
            "notes": "Use headless browser-based tools to scan Python-backed web UIs for accessibility issues on high-traffic routes.",
            "verification": "For Python-backed web UIs, run the configured accessibility tooling (for example, pa11y or axe via a headless browser) against key routes and verify that critical issues are fixed or tracked."
          },
          "rust": {
            "exampleTools": ["axe-core", "pa11y"],
            "exampleConfigFiles": [],
            "notes": "For Rust web frameworks (Actix, Axum, Rocket), use headless browser-based accessibility tools to audit rendered HTML.",
            "verification": "For web-facing Rust apps, run accessibility audits against key routes using axe or pa11y."
          },
          "go": {
            "exampleTools": ["axe-core", "pa11y"],
            "exampleConfigFiles": [],
            "notes": "For Go web apps, use headless browser-based accessibility tools to audit rendered HTML from templates.",
            "verification": "For web-facing Go apps, run accessibility audits against key routes using axe or pa11y."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "ai-drift-detection",
        "label": "AI Drift Detection",
        "description": "Run nightly or scheduled checks comparing AI-generated outputs against pinned baselines to detect model drift, prompt drift, or code changes affecting AI behavior. Attribute regressions to code changes vs model updates vs prompt changes.",
        "executionStage": "nightly",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "nightly",
            "notes": "Run AI drift detection in a scheduled nightly pipeline separate from main CI."
          },
          "github-actions": {
            "job": "nightly",
            "notes": "Use scheduled workflow (cron) to run AI drift detection nightly."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["jest snapshots", "custom baseline comparator"],
            "exampleConfigFiles": ["__snapshots__/", "ai-baselines/"],
            "notes": "Pin AI outputs as baseline snapshots. Nightly runs compare current outputs against baselines. When drift detected, investigate: was it a code change, model update, or prompt change? Log model version, prompt hash, and code SHA for attribution.",
            "verification": "Run AI baseline tests and confirm outputs match pinned baselines or drift is intentional."
          },
          "csharp-dotnet": {
            "exampleTools": ["Verify", "custom baseline tests"],
            "exampleConfigFiles": ["*.verified.txt", "ai-baselines/"],
            "notes": "Use Verify library or custom comparison tests to detect AI output drift. Run nightly to catch model-side changes that don't show up in code diffs.",
            "verification": "Run AI baseline tests and confirm outputs match pinned baselines."
          },
          "python": {
            "exampleTools": ["pytest", "deepdiff", "great_expectations"],
            "exampleConfigFiles": ["tests/ai_baselines/", "pytest.ini"],
            "notes": "Create golden output tests for AI-generated content. Use deepdiff for structured comparison. For ML models, also track metrics drift (accuracy, latency) not just output drift.",
            "verification": "Run AI baseline tests nightly and confirm outputs match or drift is documented."
          },
          "rust": {
            "exampleTools": ["insta", "custom baseline tests"],
            "exampleConfigFiles": ["snapshots/", "ai-baselines/"],
            "notes": "Use insta for snapshot testing of AI outputs. Pin model versions and prompt templates. Run nightly to detect drift.",
            "verification": "Run 'cargo insta test' and confirm AI outputs match baselines."
          },
          "go": {
            "exampleTools": ["go test", "golden files"],
            "exampleConfigFiles": ["testdata/golden/", "ai-baselines/"],
            "notes": "Use golden file testing pattern for AI outputs. Compare current output against pinned baselines nightly.",
            "verification": "Run golden tests and confirm AI outputs match baselines."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "ai-schema-enforcement",
        "label": "AI Output Schema Enforcement",
        "description": "Validate all AI-generated outputs against strict JSON schemas or type definitions at system boundaries. Reject invalid outputs early rather than letting malformed data propagate through the system.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run schema validation tests as part of quality gates."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Include AI output schema validation in CI test suite."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["zod", "ajv", "TypeScript"],
            "exampleConfigFiles": ["src/schemas/", "*.schema.json"],
            "notes": "Define strict schemas for AI outputs using Zod or JSON Schema. Parse and validate AI responses at integration boundaries. Fail fast on schema violations rather than handling partial/invalid data.",
            "verification": "Review AI integration code and confirm all AI outputs are validated against schemas."
          },
          "csharp-dotnet": {
            "exampleTools": [
              "System.Text.Json",
              "FluentValidation",
              "JsonSchema.Net"
            ],
            "exampleConfigFiles": ["*.schema.json", "Schemas/"],
            "notes": "Use strongly-typed DTOs with validation attributes or FluentValidation for AI outputs. Deserialize with strict settings that reject unknown properties.",
            "verification": "Review AI integration code and confirm outputs are validated against schemas."
          },
          "python": {
            "exampleTools": ["pydantic", "jsonschema", "marshmallow"],
            "exampleConfigFiles": ["schemas/", "models.py"],
            "notes": "Use Pydantic models for AI output validation. Enable strict mode to reject extra fields. Define clear schemas at system boundaries where AI outputs enter the codebase.",
            "verification": "Review AI integration code and confirm Pydantic or equivalent validation is in place."
          },
          "rust": {
            "exampleTools": ["serde", "jsonschema", "validator"],
            "exampleConfigFiles": ["src/schemas/"],
            "notes": "Use serde with #[serde(deny_unknown_fields)] for strict deserialization of AI outputs. Add validator derives for business rule validation.",
            "verification": "Review AI integration code and confirm strict deserialization is enforced."
          },
          "go": {
            "exampleTools": ["go-playground/validator", "gojsonschema"],
            "exampleConfigFiles": ["schemas/"],
            "notes": "Define struct tags for JSON unmarshaling and use validator for additional constraints. Reject AI outputs that don't match expected schema.",
            "verification": "Review AI integration code and confirm schema validation is in place."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "ai-golden-tests",
        "label": "AI Golden Contract Tests",
        "description": "Validate AI tool-generated patches, configs, and code against exact expected formats. Test that AI outputs respect forbidden paths, file patterns, and format constraints through golden contract tests.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "test",
            "notes": "Run AI golden tests as part of the test stage."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Include AI golden contract tests in CI test suite."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["jest", "vitest"],
            "exampleConfigFiles": ["__fixtures__/ai-outputs/", "*.golden.json"],
            "notes": "Create golden test fixtures for AI-generated patches and configs. Test that outputs match exact formats, don't touch forbidden paths (node_modules, .git), and respect file naming conventions.",
            "verification": "Run golden tests and confirm AI outputs match expected fixtures exactly."
          },
          "csharp-dotnet": {
            "exampleTools": ["xUnit", "Verify"],
            "exampleConfigFiles": ["TestData/", "*.verified.json"],
            "notes": "Use Verify for golden file testing of AI outputs. Ensure AI-generated code respects namespace conventions and doesn't modify protected files.",
            "verification": "Run golden tests and confirm AI outputs match verified snapshots."
          },
          "python": {
            "exampleTools": ["pytest", "syrupy"],
            "exampleConfigFiles": ["tests/fixtures/", "__snapshots__/"],
            "notes": "Use pytest with syrupy for snapshot testing AI outputs. Test that generated code follows project conventions and respects forbidden paths.",
            "verification": "Run snapshot tests and confirm AI outputs match golden fixtures."
          },
          "rust": {
            "exampleTools": ["insta"],
            "exampleConfigFiles": ["snapshots/"],
            "notes": "Use insta for snapshot testing AI-generated code and configs. Test format compliance and forbidden path restrictions.",
            "verification": "Run 'cargo insta test' and confirm AI outputs match snapshots."
          },
          "go": {
            "exampleTools": ["go test", "golden files"],
            "exampleConfigFiles": ["testdata/"],
            "notes": "Use golden file pattern for AI output testing. Verify generated code follows Go conventions and doesn't modify vendor/ or other protected paths.",
            "verification": "Run golden tests and confirm AI outputs match expected files."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "ai-safety-checks",
        "label": "AI Adversarial & Safety Testing",
        "description": "Test AI integrations for prompt injection resistance, input sanitization, output filtering, and data exfiltration prevention. Include adversarial test cases that attempt to manipulate AI behavior.",
        "executionStage": "ci-main",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "security",
            "notes": "Run AI safety tests as part of security stage on main branch."
          },
          "github-actions": {
            "job": "security",
            "notes": "Run AI safety checks on main branch merges."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["jest", "custom adversarial tests"],
            "exampleConfigFiles": ["tests/ai-safety/"],
            "notes": "Create adversarial test suite with prompt injection attempts, malicious input patterns, and exfiltration scenarios. Test that AI outputs are sanitized before use in sensitive contexts (SQL, shell, HTML).",
            "verification": "Run AI safety test suite and confirm all adversarial cases are handled safely."
          },
          "csharp-dotnet": {
            "exampleTools": ["xUnit", "custom security tests"],
            "exampleConfigFiles": ["Tests/AiSafety/"],
            "notes": "Test prompt injection resistance and output sanitization. Ensure AI outputs are escaped/validated before use in SQL queries, command execution, or HTML rendering.",
            "verification": "Run AI safety tests and confirm adversarial inputs are handled safely."
          },
          "python": {
            "exampleTools": ["pytest", "hypothesis"],
            "exampleConfigFiles": ["tests/ai_safety/"],
            "notes": "Use hypothesis for property-based testing of AI input handling. Test prompt injection, output sanitization, and data boundary enforcement.",
            "verification": "Run AI safety tests including adversarial cases."
          },
          "rust": {
            "exampleTools": ["proptest", "custom tests"],
            "exampleConfigFiles": ["tests/ai_safety/"],
            "notes": "Use proptest for property-based testing of AI input validation. Test that malicious inputs don't escape sandboxing.",
            "verification": "Run AI safety tests with adversarial inputs."
          },
          "go": {
            "exampleTools": ["go test", "go-fuzz"],
            "exampleConfigFiles": ["ai_safety_test.go"],
            "notes": "Create adversarial test cases for AI integrations. Use fuzzing to discover input handling edge cases.",
            "verification": "Run AI safety tests and fuzz tests."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "ai-provenance-tracking",
        "label": "AI Provenance & Audit Logging",
        "description": "Log AI provider, model version, prompt template version, parameters, and tool versions for all AI operations. Enable attribution of outputs to specific model+prompt combinations for debugging and compliance.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Verify AI provenance logging is implemented in quality checks."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Check AI provenance logging implementation in CI."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["OpenTelemetry", "custom logging"],
            "exampleConfigFiles": ["src/ai/provenance.ts"],
            "notes": "Log for each AI call: provider (OpenAI, Anthropic), model ID, prompt template hash/version, temperature, timestamp, request ID. Store provenance alongside outputs for debugging 'why did AI do X?'",
            "verification": "Review AI integration code and confirm provenance is logged for all AI calls."
          },
          "csharp-dotnet": {
            "exampleTools": ["OpenTelemetry", "Serilog"],
            "exampleConfigFiles": ["AiProvenance.cs"],
            "notes": "Use structured logging to capture AI call provenance. Include model version, prompt hash, and parameters in log context.",
            "verification": "Review AI integration and confirm provenance logging is implemented."
          },
          "python": {
            "exampleTools": ["structlog", "OpenTelemetry", "MLflow"],
            "exampleConfigFiles": ["ai/provenance.py"],
            "notes": "Log AI provenance using structlog or MLflow tracking. For ML models, also track training data version and model artifact hash.",
            "verification": "Review AI integration and confirm provenance is tracked."
          },
          "rust": {
            "exampleTools": ["tracing", "OpenTelemetry"],
            "exampleConfigFiles": ["src/ai/provenance.rs"],
            "notes": "Use tracing spans to capture AI call provenance. Include model version, prompt hash, and parameters as span attributes.",
            "verification": "Review AI integration and confirm provenance is logged."
          },
          "go": {
            "exampleTools": ["slog", "OpenTelemetry"],
            "exampleConfigFiles": ["ai/provenance.go"],
            "notes": "Use structured logging (slog) to capture AI provenance. Include model, prompt version, and parameters in log context.",
            "verification": "Review AI integration and confirm provenance logging is implemented."
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      },
      {
        "id": "agent-invariants",
        "label": "Autonomous Agent Invariants",
        "description": "Maintain INVARIANTS.md defining repository-wide rules that must always hold true, with machine-readable verification commands for autonomous agents.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run invariant verification commands in a dedicated quality stage."
          },
          "github-actions": {
            "job": "ci",
            "notes": "Add invariant checks to existing CI job or create dedicated invariants job."
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": ["INVARIANTS.md"],
            "notes": "Create INVARIANTS.md with a table of rules, verification commands, and severity levels. Include commands like 'npm test', 'npm run lint', 'npm run typecheck' that agents can run to validate state.",
            "verification": "INVARIANTS.md exists with machine-readable verification commands for all critical repository rules.",
            "requiredFiles": ["INVARIANTS.md"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": ["INVARIANTS.md"],
            "notes": "Document invariants with verification commands like 'dotnet test', 'dotnet format --verify-no-changes', 'dotnet build' for autonomous validation.",
            "verification": "INVARIANTS.md exists with machine-readable verification commands.",
            "requiredFiles": ["INVARIANTS.md"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": ["INVARIANTS.md"],
            "notes": "List invariants with commands like 'pytest', 'ruff check', 'mypy' that agents can execute to verify repository state.",
            "verification": "INVARIANTS.md exists with machine-readable verification commands.",
            "requiredFiles": ["INVARIANTS.md"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": ["INVARIANTS.md"],
            "notes": "Document invariants with verification commands like 'cargo test', 'cargo clippy', 'cargo fmt --check' for deterministic validation.",
            "verification": "INVARIANTS.md exists with machine-readable verification commands.",
            "requiredFiles": ["INVARIANTS.md"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": ["INVARIANTS.md"],
            "notes": "Specify invariants with commands like 'go test ./...', 'golangci-lint run', 'go vet ./...' that agents can use for validation.",
            "verification": "INVARIANTS.md exists with machine-readable verification commands.",
            "requiredFiles": ["INVARIANTS.md"]
          }
        },
        "enforcement": "recommended",
        "severity": "warn"
      }
    ],
    "optionalEnhancements": [
      {
        "id": "observability",
        "label": "Observability (Logging & Error Handling)",
        "description": "Standardize error handling and structured logging to make debugging and production monitoring easier.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "observability"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": ["Winston", "Pino"],
            "exampleConfigFiles": [],
            "notes": "Adopt structured JSON logging with correlation IDs and send logs to a centralized sink in production.",
            "verification": "Confirm that a structured logging library (such as Winston or Pino) is configured to emit JSON or key-value logs and that error handling routes important failures through this logger."
          },
          "csharp-dotnet": {
            "exampleTools": ["Serilog", "NLog"],
            "exampleConfigFiles": ["appsettings.json"],
            "notes": "Configure structured logging for your .NET services and ensure exceptions and key events are logged with useful context.",
            "verification": "Confirm that a structured logging library (such as Serilog or NLog) is configured with an agreed sink and format, and that the application logs meaningful context for errors and key events."
          },
          "python": {
            "exampleTools": ["structlog", "loguru"],
            "exampleConfigFiles": [
              "logging configuration files",
              "pyproject.toml"
            ],
            "notes": "Use structured logging for Python services and ensure critical paths record enough context to debug issues after the fact.",
            "verification": "Confirm that a structured logging setup (such as structlog or configured logging with JSON formatting) is in place and that critical paths log enough information to debug failures in production."
          },
          "rust": {
            "exampleTools": ["tracing", "log"],
            "exampleConfigFiles": [],
            "notes": "Use the tracing crate for structured logging with spans and events. Configure tracing-subscriber for output formatting.",
            "verification": "Confirm that tracing or log crate is configured with appropriate subscriber/logger and emits structured output."
          },
          "go": {
            "exampleTools": ["slog", "zap", "zerolog"],
            "exampleConfigFiles": [],
            "notes": "Use slog (stdlib) or zap/zerolog for structured logging. Configure JSON output for production and text for development.",
            "verification": "Confirm that a structured logging library is configured with appropriate output format and log levels."
          }
        },
        "enforcement": "optional",
        "severity": "info"
      },
      {
        "id": "agent-phase-gates",
        "label": "Agent Phase Gates",
        "description": "Define phase transition requirements in phase-gates.md for autonomous agent workflows with clear pre-conditions and approval gates.",
        "executionStage": "ci-pr",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": ["phase-gates.md"],
            "notes": "Document phase transitions (Planning  Implementation  Verification  Release) with required pre-conditions, approval mechanisms, and evidence artifacts for each gate.",
            "verification": "phase-gates.md exists defining transition requirements between project phases.",
            "optionalFiles": ["phase-gates.md"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": ["phase-gates.md"],
            "notes": "Define phase gates with .NET-specific verification (dotnet test, coverage reports, NuGet package publishing) and approval workflows.",
            "verification": "phase-gates.md exists defining transition requirements.",
            "optionalFiles": ["phase-gates.md"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": ["phase-gates.md"],
            "notes": "Specify phase transitions with Python-specific checks (pytest results, wheel/sdist builds, PyPI publication) and approval processes.",
            "verification": "phase-gates.md exists defining transition requirements.",
            "optionalFiles": ["phase-gates.md"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": ["phase-gates.md"],
            "notes": "Document phase gates with Rust-specific verification (cargo test, cargo check, crates.io publishing) and sign-off requirements.",
            "verification": "phase-gates.md exists defining transition requirements.",
            "optionalFiles": ["phase-gates.md"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": ["phase-gates.md"],
            "notes": "Define gates with Go-specific checks (go test, go vet, module tagging) and approval workflows for phase transitions.",
            "verification": "phase-gates.md exists defining transition requirements.",
            "optionalFiles": ["phase-gates.md"]
          }
        },
        "enforcement": "optional",
        "severity": "info"
      },
      {
        "id": "agent-victory-gates",
        "label": "Agent Victory Gates",
        "description": "Document milestone completion criteria in victory-gates.md defining 'done' for releases and major deliverables with evidence requirements.",
        "executionStage": "release",
        "appliesTo": {
          "stacks": ["typescript-js", "csharp-dotnet", "python", "rust", "go"]
        },
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          },
          "github-actions": {
            "job": "ci"
          }
        },
        "stackHints": {
          "typescript-js": {
            "exampleTools": [],
            "exampleConfigFiles": ["victory-gates.md"],
            "notes": "Define completion criteria for milestones (MVP, Beta, GA) with all required conditions, verification commands, and evidence artifacts (test reports, coverage, deployment confirmations).",
            "verification": "victory-gates.md exists with milestone completion criteria and evidence requirements.",
            "optionalFiles": ["victory-gates.md"]
          },
          "csharp-dotnet": {
            "exampleTools": [],
            "exampleConfigFiles": ["victory-gates.md"],
            "notes": "Specify victory conditions for releases including .NET-specific requirements (NuGet publishing, deployment validation, documentation) and evidence collection.",
            "verification": "victory-gates.md exists with milestone criteria.",
            "optionalFiles": ["victory-gates.md"]
          },
          "python": {
            "exampleTools": [],
            "exampleConfigFiles": ["victory-gates.md"],
            "notes": "Document release readiness gates with Python-specific criteria (PyPI publishing, wheel distribution, dependency compatibility) and proof artifacts.",
            "verification": "victory-gates.md exists with milestone criteria.",
            "optionalFiles": ["victory-gates.md"]
          },
          "rust": {
            "exampleTools": [],
            "exampleConfigFiles": ["victory-gates.md"],
            "notes": "Define done criteria including Rust-specific conditions (crates.io publication, documentation hosting, security audits) with evidence requirements.",
            "verification": "victory-gates.md exists with milestone criteria.",
            "optionalFiles": ["victory-gates.md"]
          },
          "go": {
            "exampleTools": [],
            "exampleConfigFiles": ["victory-gates.md"],
            "notes": "Specify completion gates with Go-specific requirements (module tagging, pkg.go.dev documentation, binary distribution) and validation artifacts.",
            "verification": "victory-gates.md exists with milestone criteria.",
            "optionalFiles": ["victory-gates.md"]
          }
        },
        "enforcement": "optional",
        "severity": "info"
      }
    ]
  }
}
