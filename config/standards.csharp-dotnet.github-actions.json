{
  "version": 5,
  "stack": "csharp-dotnet",
  "stackLabel": "C# / .NET",
  "ciSystems": ["github-actions"],
  "meta": {
    "defaultCoverageThreshold": 0.8,
    "coverageThresholdUnit": "ratio",
    "coverageThresholdDescription": "Expressed as a ratio (0-1), e.g., 0.8 = 80% coverage. Must be between 0 and 1.",
    "complexityChecks": {
      "enabledByDefault": true,
      "description": "When supported by the stack, run cyclomatic complexity or similar metrics in CI as a warning-only check initially."
    },
    "qualityGatePolicy": {
      "preferSoftFailOnLegacy": true,
      "description": "New quality checks should warn on existing code and fail CI only for violations introduced in new or changed code, to reduce friction on legacy codebases."
    },
    "migrationGuide": [
      {
        "step": 0,
        "title": "Foundation: Line Endings and Hook Entry Point",
        "description": "Configure .gitattributes for cross-platform line ending correctness and establish the canonical verify entrypoint before adding any checks. This prevents 'works locally, fails in CI' issues from day one.",
        "focusIds": [
          "gitattributes-eol",
          "canonical-verify",
          "hook-ci-parity",
          "config-authority"
        ],
        "notes": "Start here to avoid debugging cryptic CRLF failures later. Use .gitattributes as the authority for EOL (not .editorconfig). Run 'git add --renormalize .' after adding .gitattributes to fix existing files."
      },
      {
        "step": 1,
        "title": "Establish Local Safety Nets First",
        "description": "Add pre-commit hooks with secret scanning, formatting, and linting. Hooks should CHECK (not auto-fix) and scope to changed files only for speed.",
        "focusIds": [
          "pre-commit-hooks",
          "secret-scanning-precommit",
          "linting",
          "code-formatter"
        ],
        "notes": "Keep hooks fast by scoping to staged files. Use Husky as entry point calling lint-staged or pre-commit. Hooks should check, not fix, to keep developers aware of issues."
      },
      {
        "step": 2,
        "title": "Mirror Local Checks in CI with CRLF Detection",
        "description": "Introduce CI quality gates that mirror local hooks exactly. Add CRLF detection early in pipeline. Treat existing violations as warnings where possible.",
        "focusIds": [
          "crlf-detection",
          "ci-quality-gates",
          "linting",
          "code-formatter",
          "commit-linting"
        ],
        "notes": "CI must call the same verify scripts that hooks use. Add CRLF detection before other checks to fail fast on line ending issues. Use diff-based tools so only new violations break builds."
      },
      {
        "step": 3,
        "title": "Add Type Safety, Coverage, and Dependency Security",
        "description": "Enable type-checking, coverage thresholds, and dependency/vulnerability scanning with gradual enforcement.",
        "focusIds": [
          "type-checking",
          "unit-test-runner",
          "unit-test-reporter",
          "dependency-security",
          "dependency-update-automation"
        ],
        "notes": "Pin tool and runtime versions in CI and containers to avoid flaky differences across environments."
      },
      {
        "step": 4,
        "title": "Layer in Docs, Governance, and Recommended Checks",
        "description": "Add documentation standards, governance files, integration testing, performance baselines, complexity analysis, accessibility auditing, and (optionally) ML-specific practices for data-heavy Python repos.",
        "focusIds": [
          "documentation",
          "repository-governance",
          "integration-testing",
          "performance-baselining",
          "complexity-analysis",
          "accessibility-auditing"
        ],
        "notes": "Tackle recommended items in order of business value; backend-only repos can skip web-focused checks like accessibility."
      },
      {
        "step": 5,
        "title": "AI/ML Governance (If Applicable)",
        "description": "For repos using or building with generative AI, add drift detection, schema enforcement, golden contract tests, safety testing, and provenance tracking.",
        "focusIds": [
          "ai-drift-detection",
          "ai-schema-enforcement",
          "ai-golden-tests",
          "ai-safety-checks",
          "ai-provenance-tracking"
        ],
        "notes": "Skip this step if your repo has no AI/ML components. For AI-heavy repos: add nightly drift detection to catch model changes, enforce strict schemas at AI output boundaries, and log provenance for debugging 'why did AI do X?'"
      }
    ],
    "executorHints": {
      "description": "Advisory execution substrate hints. Bazel is the first supported executor; future monorepo executors may follow the same pattern.",
      "bazel": {
        "detectionRules": {
          "rootMarkers": ["MODULE.bazel", "WORKSPACE.bazel", "WORKSPACE"],
          "optionalMarkers": [".bazelrc", ".bazelversion"],
          "notes": "Detection uses repo-root markers only. Nested BUILD files do not trigger Bazel mode."
        },
        "optOut": {
          "description": "Set meta.executorHints.bazel.enabled = false in repo config to disable Bazel hints",
          "configPath": "meta.executorHints.bazel.enabled"
        },
        "targetConventions": {
          "description": "Recommended target naming (not assumed to exist). These are illustrative patterns; actual targets are repo-defined.",
          "lint": "//tools/lint:lint or bazel test //... with lint aspects",
          "format": "bazel run //tools/format:check",
          "test": "bazel test //...",
          "coverage": "bazel coverage //...",
          "build": "bazel build //..."
        },
        "ciContract": {
          "versionPinning": "Use .bazelversion file for Bazelisk",
          "configFlag": "--config=ci (define in .bazelrc)",
          "deterministicFlags": ["--nokeep_going", "--test_output=errors"],
          "remoteCache": "Optional; not required for CI"
        },
        "advisoryNotice": "bazelHints are suggestions, not required execution paths. Consumers should prefer stack-native commands unless explicitly adopting Bazel."
      }
    }
  },
  "checklist": {
    "core": [
      {
        "id": "gitattributes-eol",
        "label": "Git Attributes (Line Endings)",
        "description": "Enforce line endings at the Git layer using .gitattributes. Mark text files with appropriate EOL handling (eol=lf for shell scripts, eol=auto for most files) and binary files as binary to prevent corruption. This prevents 'works locally, fails in CI' issues caused by CRLF/LF mismatches.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Add .gitattributes check as first step in CI job."
          }
        },
        "stack": {
          "exampleTools": ["git"],
          "exampleConfigFiles": [".gitattributes", ".editorconfig"],
          "notes": "Use .gitattributes for EOL authority. Mark *.sh, *.ps1 scripts appropriately. .editorconfig drives editor behavior but .gitattributes is the source of truth for Git operations.",
          "verification": "Run 'git ls-files --eol' to check EOL consistency.",
          "requiredFiles": [".gitattributes"],
          "optionalFiles": [".editorconfig"],
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Verify no CRLF in shell scripts"
          }
        }
      },
      {
        "id": "crlf-detection",
        "label": "CRLF Detection in CI",
        "description": "Fail CI early for Linux-executed files containing CRLF line endings. Shell scripts, Python files, and other interpreted files fail silently or with cryptic errors when they contain \\r characters. Detect this before running deeper CI steps.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Add CRLF detection step before main CI steps."
          }
        },
        "stack": {
          "exampleTools": ["file", "grep"],
          "exampleConfigFiles": [],
          "notes": "Detect CRLF in shell scripts and CI configuration files. C# source files can tolerate CRLF but shell scripts cannot.",
          "verification": "Run CRLF detection on .sh files in CI.",
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.sh$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Detect CRLF in shell scripts"
          }
        }
      },
      {
        "id": "gitignore-and-dockerignore",
        "label": "Git and Docker Ignore Files",
        "description": "Maintain proper .gitignore and .dockerignore files to prevent committing secrets, build artifacts, or unnecessary files.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleConfigFiles": [".gitignore", ".dockerignore"],
          "notes": "Use the official github/gitignore VisualStudio/.NET template. .dockerignore must exclude bin/, obj/, .vs/, *.user, and similar local/build artifacts.",
          "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
          "requiredFiles": [".gitignore"],
          "optionalFiles": [".dockerignore"]
        }
      },
      {
        "id": "linting",
        "label": "Linting",
        "description": "Run static code linting to enforce consistency and catch common issues early.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["Roslyn analyzers", "StyleCop"],
          "exampleConfigFiles": [".editorconfig", "Directory.Build.props"],
          "notes": "Enable analyzers or style rules for the solution and review warnings regularly; enforce stricter rules on new code.",
          "verification": ".editorconfig must exist to drive the .NET formatting and analysis tooling.",
          "requiredFiles": [".editorconfig"],
          "optionalFiles": ["Directory.Build.props"],
          "bazelHints": {
            "commands": [
              "bazel build //... --aspects=@rules_dotnet//dotnet:analyzers.bzl%analyzer_aspect"
            ],
            "notes": "Example only; actual targets are repo-defined. Use rules_dotnet analyzer aspects for Roslyn-based linting."
          }
        }
      },
      {
        "id": "unit-test-runner",
        "label": "Unit Test Runner",
        "description": "Provide a deterministic unit test framework with a single command to run all tests.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["xUnit", "NUnit", "MSTest"],
          "exampleConfigFiles": ["*.Tests.csproj"],
          "notes": "Group unit tests into dedicated test projects and keep them independent from external services.",
          "verification": "Test projects are present in the solution; test configuration is defined.",
          "optionalFiles": ["*.Tests.csproj"],
          "bazelHints": {
            "commands": ["bazel test //..."],
            "notes": "Use rules_dotnet to define test targets for xUnit/NUnit/MSTest projects."
          }
        }
      },
      {
        "id": "containerization",
        "label": "Containerization (Docker / Docker Compose)",
        "description": "Provide a Dockerfile and, if applicable, a docker-compose file for local dev and CI parity.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
          "notes": "Use multi-stage builds for .NET publish output and pin the SDK/runtime image versions to match CI.",
          "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
          "requiredFiles": ["Dockerfile"],
          "optionalFiles": ["docker-compose.yml"]
        }
      },
      {
        "id": "semantic-versioning",
        "label": "Semantic Versioning",
        "description": "Use MAJOR.MINOR.PATCH versioning with clear rules and automated changelog generation based on commit history. Maintain a single canonical version source (for example, package.json or VERSION) that all release artifacts use.",
        "ciHints": {
          "github-actions": {
            "job": "release"
          }
        },
        "stack": {
          "exampleTools": ["GitVersion"],
          "exampleConfigFiles": ["GitVersion.yml", "*.csproj", "CHANGELOG.md"],
          "notes": "Use GitVersion (or Directory.Build.props) as the single canonical version source, computed from git history, and feed it into assembly/package versions. Configure CI to auto-generate or update CHANGELOG.md from commit messages and git tags. Integrate with the release pipeline to version assemblies, NuGet packages, and publish GitHub releases from the same version.",
          "verification": "Check that versioning is driven by a SemVer-aware tool (for example, GitVersion) and verify that running the release/versioning step locally or in CI produces the expected version metadata, updates project files, and generates changelog entries from commit history.",
          "requiredFiles": ["*.csproj"],
          "optionalFiles": [
            "GitVersion.yml",
            "Directory.Build.props",
            "CHANGELOG.md"
          ],
          "requiredScripts": ["release"]
        }
      },
      {
        "id": "version-guard",
        "label": "Version Guard (Automated Releases)",
        "description": "If semantic-release or automated versioning is enabled, block manual edits to canonical version fields in pull requests. Enforce a CI guard (and optional pre-push hook) that fails when version lines change outside the release workflow.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Run the version guard in PR workflows against the base ref."
          }
        },
        "stack": {
          "exampleTools": ["GitVersion", "git"],
          "exampleConfigFiles": [
            "scripts/check-version-unchanged.sh",
            ".github/workflows/ci.yml",
            "azure-pipelines.yml"
          ],
          "notes": "When GitVersion or similar tooling computes versions, block manual edits to Directory.Build.props or *.csproj version fields via the version guard. Allow changes only in release automation.",
          "verification": "Run the guard and confirm it fails when <Version> or <VersionPrefix> changes in props/csproj files.",
          "optionalFiles": ["Directory.Build.props", "*.csproj", "VERSION"]
        }
      },
      {
        "id": "unified-release-workflow",
        "label": "Unified Release Workflow",
        "description": "Use a single CI release pipeline that publishes all artifacts (GitHub releases, packages, containers) from the same canonical version source.",
        "ciHints": {
          "github-actions": {
            "job": "release"
          }
        },
        "stack": {
          "exampleTools": ["GitVersion", "dotnet pack", "dotnet nuget push"],
          "exampleConfigFiles": [
            "azure-pipelines.yml",
            ".github/workflows/release.yml"
          ],
          "notes": "Use a single release pipeline to publish NuGet packages, GitHub releases, and Docker images from the canonical version source (GitVersion or Directory.Build.props).",
          "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
          "requiredScripts": ["release"],
          "optionalFiles": ["GitVersion.yml", "Directory.Build.props"]
        }
      },
      {
        "id": "release-hook-bypass",
        "label": "Release Hook Bypass",
        "description": "Release automation must bypass local developer hooks (HUSKY=0, --no-verify) and rely solely on CI gates for validation. This ensures idempotent, reproducible releases that don't fail due to hook environment differences.",
        "ciHints": {
          "github-actions": {
            "job": "release",
            "notes": "Set HUSKY=0 or equivalent in release job to disable hooks."
          }
        },
        "stack": {
          "exampleTools": ["GitVersion"],
          "exampleConfigFiles": [
            "azure-pipelines.yml",
            ".github/workflows/release.yml"
          ],
          "notes": "Release pipelines should skip local hooks. If using Lefthook, set LEFTHOOK=0. Rely on CI gates for all validation.",
          "verification": "Check release pipeline for hook bypass configuration."
        }
      },
      {
        "id": "commit-linting",
        "label": "Commit Linting",
        "description": "Enforce structured commit messages such as Conventional Commits via commit-msg hooks and CI. This is required for deterministic versioning and changelog generation.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["commitlint", "commitizen"],
          "exampleConfigFiles": ["commitlint.config.*", ".cz.toml"],
          "notes": "Document your Conventional Commit convention and enforce it via commit-msg hooks and CI so release tooling can compute versions deterministically.",
          "verification": "Create a test commit following the documented convention and confirm that commit-msg hooks and CI checks accept it.",
          "anyOfFiles": [
            "commitlint.config.js",
            "commitlint.config.cjs",
            "commitlint.config.mjs",
            "commitlint.config.json",
            ".cz.toml"
          ],
          "requiredScripts": ["commitlint"]
        }
      },
      {
        "id": "unit-test-reporter",
        "label": "Unit Test Reporter / Coverage",
        "description": "Generate readable unit test and coverage reports and enforce a minimum coverage threshold (around 80%) for new or changed code.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["coverlet", "ReportGenerator"],
          "exampleConfigFiles": ["*.csproj"],
          "notes": "Enable coverage collection for test projects and publish reports in a human-friendly format from CI.",
          "verification": "Run the test suite with coverage enabled (for example, using coverlet or a similar tool) and verify that coverage reports are generated and used in CI to monitor thresholds.",
          "bazelHints": {
            "commands": ["bazel coverage //..."],
            "notes": "Use rules_dotnet with coverage instrumentation enabled."
          }
        }
      },
      {
        "id": "ci-quality-gates",
        "label": "CI Quality Gates",
        "description": "Single CI pipeline that runs linting, formatting, type checking, tests, coverage, build, and containerization.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [".github/workflows/*", "azure-pipelines.yml"],
          "notes": "Ensure CI runs analyzers, tests, build, and packaging or container checks before changes can be merged.",
          "verification": "Open the CI configuration and verify there is a job or stage that runs analyzers, tests, build, and any required packaging or container checks before merging to main.",
          "bazelHints": {
            "commands": ["bazel build //...", "bazel test //..."],
            "notes": "Bazel handles all analysis, testing, and packaging via defined targets."
          }
        }
      },
      {
        "id": "code-formatter",
        "label": "Code Formatter",
        "description": "Automatic code formatting to maintain a consistent style across all contributors.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["dotnet format"],
          "exampleConfigFiles": [".editorconfig"],
          "notes": "Use .editorconfig and dotnet-format to keep C# style consistent across contributors.",
          "verification": "Run the configured formatter or code style enforcement (for example, `dotnet format`) and confirm that code in the repository conforms to the defined rules.",
          "bazelHints": {
            "commands": [
              "bazel run //tools/format:dotnet_format -- --verify-no-changes"
            ],
            "notes": "Wrap dotnet format as a Bazel run target."
          }
        }
      },
      {
        "id": "pre-commit-hooks",
        "label": "Pre-Commit Hooks",
        "description": "Use git hooks to run linting, formatting, and commit linting before changes are committed. Hooks should CHECK by default (not auto-fix), be fast, and scope to changed files only. Use a single entry hook mechanism (e.g., Husky as entry point calling pre-commit or lint-staged).",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Hooks and CI must invoke identical verification commands. Use npm run verify or equivalent."
          }
        },
        "stack": {
          "exampleTools": ["Lefthook", "husky.net"],
          "exampleConfigFiles": ["lefthook.yml", ".husky/"],
          "notes": "Configure Lefthook or husky.net to run formatting checks (not auto-fix) on staged files. Hooks should be deterministic and environment-pinned via global.json SDK version.",
          "verification": "Inspect hook configuration and confirm checks run in verify mode, not auto-fix mode."
        }
      },
      {
        "id": "hook-ci-parity",
        "label": "Hook/CI Parity",
        "description": "Local hooks and CI must invoke identical verification commands to prevent 'works locally, fails in CI' issues. Use a single canonical verify entrypoint (e.g., npm run verify) that both hooks and CI call.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "CI should call the same verify script that hooks use locally."
          }
        },
        "stack": {
          "exampleTools": ["dotnet CLI", "make"],
          "exampleConfigFiles": ["Makefile", "Directory.Build.props"],
          "notes": "Define a verify target (make verify or dotnet cake verify) that both hooks and CI invoke. Keep verification logic in one place.",
          "verification": "Compare hook commands with CI commands and confirm they invoke the same targets."
        }
      },
      {
        "id": "secret-scanning-precommit",
        "label": "Pre-commit Secret Scanning",
        "description": "Scan staged diffs for credentials, API keys, and secrets before they reach the remote repository. Catch secrets at commit time rather than after they're pushed.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Enable GitHub secret scanning and also run gitleaks in CI."
          }
        },
        "stack": {
          "exampleTools": ["gitleaks", "detect-secrets"],
          "exampleConfigFiles": [".gitleaks.toml"],
          "notes": "Add gitleaks to pre-commit hooks via Lefthook. Scan staged changes before commits.",
          "verification": "Run 'gitleaks protect --staged' and verify it catches test secrets."
        }
      },
      {
        "id": "type-checking",
        "label": "Type Checking",
        "description": "Use static type checking to catch errors before runtime and enforce strictness on new code. For JS/TS stacks, require a TypeScript-first policy with strict mode and a CI typecheck step; allow JSDoc/checkJs migration for legacy JS.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["Roslyn analyzers"],
          "exampleConfigFiles": [
            ".editorconfig",
            "Directory.Build.props",
            "*.csproj"
          ],
          "notes": "Enable nullable reference types and relevant analyzers to catch type and nullability issues at compile time. C# project files (*.csproj) indicate the presence of projects that can be type-checked.",
          "verification": ".editorconfig must exist; Directory.Build.props is optional for shared build configuration.",
          "requiredFiles": [".editorconfig"],
          "optionalFiles": ["Directory.Build.props"],
          "bazelHints": {
            "commands": ["bazel build //..."],
            "notes": "Example only; actual targets are repo-defined. C# type errors surface during bazel build with rules_dotnet."
          }
        }
      },
      {
        "id": "dependency-security",
        "label": "Dependency Management & Vulnerability Scanning",
        "description": "Lock dependencies and scan regularly for known vulnerabilities; fail CI on newly introduced high-severity issues.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["dotnet list package --vulnerable"],
          "exampleConfigFiles": ["packages.lock.json", "*.csproj"],
          "notes": "Enable package lock files and use vulnerability scanning to track and remediate high-risk dependencies.",
          "verification": "Dependency lockfile or package reference is present; security scanning is configured.",
          "optionalFiles": ["packages.lock.json"]
        }
      },
      {
        "id": "deterministic-builds",
        "label": "Deterministic & Hermetic Builds",
        "description": "Ensure builds are reproducible by pinning dependencies, base images, and tool/runtime versions. Avoid network/time variance and fail when lockfiles drift.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["dotnet restore --locked-mode"],
          "exampleConfigFiles": ["packages.lock.json", "global.json"],
          "notes": "Enable packages.lock.json and use locked restore. Pin SDK versions via global.json and pin base images in Dockerfiles.",
          "verification": "packages.lock.json or equivalent lock files exist and restore runs in locked mode. SDK versions are pinned.",
          "optionalFiles": ["packages.lock.json", "global.json"]
        }
      },
      {
        "id": "provenance-security",
        "label": "Provenance & Security Metadata",
        "description": "Produce SBOMs or provenance metadata, enable secret/code scanning, and sign tags or commits for critical repos.",
        "ciHints": {
          "github-actions": {
            "job": "security"
          }
        },
        "stack": {
          "exampleTools": ["sbom-tool", "codeql", "gitleaks", "cosign"],
          "exampleConfigFiles": [
            ".github/workflows/codeql.yml",
            ".github/workflows/provenance.yml"
          ],
          "notes": "Generate SBOM/provenance for NuGet and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
          "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
          "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
        }
      },
      {
        "id": "ci-templates-automation",
        "label": "CI Templates & Automation",
        "description": "Adopt standard CI templates and config samples to scale across repositories, minimizing bespoke pipeline logic.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [
            "GitHub Actions reusable workflows",
            "Azure DevOps templates"
          ],
          "exampleConfigFiles": [
            ".github/workflows/ci.yml",
            "azure-pipelines.yml"
          ],
          "notes": "Use shared CI templates for build/test/pack/release stages to standardize across .NET repos.",
          "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
          "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
          "requiredScripts": ["ci"]
        }
      },
      {
        "id": "runtime-version",
        "label": "Runtime Version Specification",
        "description": "Specify required runtime/engine versions in package manifests to ensure environment stability and prevent version-related issues across development teams.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["*.csproj", "global.json"],
          "notes": "Specify TargetFramework in .csproj files (e.g., <TargetFramework>net8.0</TargetFramework>) and optionally use global.json to pin the SDK version (e.g., { \"sdk\": { \"version\": \"8.0.100\" } }) for consistent builds across the team.",
          "verification": ".csproj files must specify TargetFramework; global.json is recommended to pin SDK version.",
          "optionalFiles": ["global.json"]
        }
      },
      {
        "id": "documentation",
        "label": "Documentation Standards",
        "description": "Maintain a comprehensive README and, where applicable, auto-generated API docs to support onboarding and maintainability.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["DocFX"],
          "exampleConfigFiles": ["README.md", "docfx.json"],
          "notes": "Keep README and API docs in sync with the solution structure and public surface area.",
          "verification": "README.md is present in the repository root; docs/ directory or DocFX configuration exists if applicable.",
          "requiredFiles": ["README.md"],
          "optionalFiles": ["docs/", "docfx.json"]
        }
      },
      {
        "id": "repository-governance",
        "label": "Repository Governance",
        "description": "Include standard governance files (LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md), branch protection rules, and review standards to define legal, ethical, and workflow expectations.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            "LICENSE",
            "CODE_OF_CONDUCT.md",
            "CONTRIBUTING.md"
          ],
          "notes": "Document contribution expectations and ensure legal and code-of-conduct policies are easy to find.",
          "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
          "requiredFiles": ["LICENSE"],
          "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
        }
      },
      {
        "id": "canonical-verify",
        "label": "Canonical Verify Entrypoint",
        "description": "Provide one canonical 'verify' command per repository/stack that all stages call with appropriate flags. This prevents duplication, drift, and ensures consistency between local development and CI.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "CI should call the canonical verify command, not duplicate check logic."
          }
        },
        "stack": {
          "exampleTools": ["dotnet CLI", "make", "cake"],
          "exampleConfigFiles": ["Makefile", "build.cake"],
          "notes": "Define 'make verify' or 'dotnet cake verify' that runs all checks. Both hooks and CI use this single entrypoint with stage-appropriate flags.",
          "verification": "Makefile or build script contains a 'verify' target."
        }
      },
      {
        "id": "config-authority",
        "label": "Config File Authority Rules",
        "description": "Each configuration rule must live in exactly one authoritative config file. Avoid duplication across .editorconfig, linter configs, and CI definitions. Document which file is authoritative for each concern.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Ensure CI reads from authoritative configs, not duplicated settings."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            ".gitattributes",
            ".editorconfig",
            "Directory.Build.props"
          ],
          "notes": "Authority mapping: .gitattributes for EOL, .editorconfig for formatting rules, Directory.Build.props for shared build settings. Roslyn analyzers read from .editorconfig.",
          "verification": "Review configs and confirm no rule is duplicated across files."
        }
      },
      {
        "id": "explicit-skip-paths",
        "label": "Explicit Skip Paths",
        "description": "Encode path exclusions and skip rules deterministically in config files, not through ad-hoc human judgment. Make it clear which paths are excluded from checks and why.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "CI should read skip paths from config files, not hardcode them in pipeline."
          }
        },
        "stack": {
          "exampleTools": ["dotnet format", "Roslyn"],
          "exampleConfigFiles": [".editorconfig"],
          "notes": "Use .editorconfig file globs to exclude generated code from analysis. Document exclusions with comments.",
          "verification": "Review .editorconfig and confirm exclusions are explicit and documented."
        }
      }
    ],
    "recommended": [
      {
        "id": "dependency-update-automation",
        "label": "Dependency Update Automation",
        "description": "Automate dependency updates using Renovate or Dependabot to keep dependencies current and reduce security exposure window.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stack": {
          "exampleTools": ["renovate", "dependabot"],
          "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
          "notes": "Both support NuGet packages. Renovate has better Central Package Management (Directory.Packages.props) support. For AzDO: use self-hosted Renovate runner.",
          "verification": "Check for renovate.json OR .github/dependabot.yml. Verify NuGet update PRs.",
          "anyOfFiles": [
            "renovate.json",
            ".renovaterc.json",
            ".github/dependabot.yml"
          ],
          "pinningNotes": "Pin Renovate version in pipeline definition."
        }
      },
      {
        "id": "dependency-architecture-rules",
        "label": "Dependency Architecture Rules",
        "description": "Enforce module boundaries and import constraints to prevent architectural drift and unwanted coupling.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "CI hints are suggested mappings; adjust to your workflow structure."
          }
        },
        "stack": {
          "exampleTools": ["NsDepCop", "ArchUnitNET"],
          "exampleConfigFiles": [
            "NsDepCop.config.nsdepcop",
            "ArchitectureTests.cs"
          ],
          "notes": "NsDepCop enforces namespace dependency rules via config file. ArchUnitNET uses test code for architectural assertions.",
          "verification": "Build fails on namespace violations, or architecture tests run as part of test suite.",
          "optionalFiles": ["NsDepCop.config.nsdepcop"]
        }
      },
      {
        "id": "integration-testing",
        "label": "Integration Testing",
        "description": "Test how components interact with each other and external systems, running after unit tests with more relaxed coverage thresholds.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["xUnit", "NUnit", "MSTest"],
          "exampleConfigFiles": ["*.IntegrationTests.csproj"],
          "notes": "Create dedicated integration test projects that exercise real infrastructure or service boundaries where appropriate.",
          "verification": "Confirm there is a test project or configuration dedicated to integration or API tests and run it to verify external or cross-service interactions behave as expected."
        }
      },
      {
        "id": "performance-baselining",
        "label": "Performance Baselines",
        "description": "Establish performance baselines and monitor for regressions using lightweight benchmarks or audits in CI.",
        "ciHints": {
          "github-actions": {
            "job": "performance"
          }
        },
        "stack": {
          "exampleTools": ["BenchmarkDotNet"],
          "exampleConfigFiles": ["*.csproj"],
          "notes": "Use BenchmarkDotNet or similar to track performance of critical methods or endpoints over time.",
          "verification": "Identify and run the configured performance or benchmarking suite (for example, BenchmarkDotNet) and review the output to ensure it is tracked against historical or target values."
        }
      },
      {
        "id": "complexity-analysis",
        "label": "Complexity Analysis",
        "description": "Measure cyclomatic complexity or similar metrics to keep code maintainable, starting as a warning-only check.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["SonarQube", "Visual Studio code metrics"],
          "exampleConfigFiles": ["sonar-project.properties"],
          "notes": "Use code metrics or Sonar analysis to flag overly complex methods and refactor them over time.",
          "verification": "Run the configured code metrics or Sonar analysis and review complexity reports for key modules, ensuring that new or changed code stays within acceptable limits."
        }
      },
      {
        "id": "accessibility-auditing",
        "label": "Accessibility Auditing",
        "description": "Run accessibility checks on web-facing components to detect critical issues and improve inclusive UX.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["axe-core", "Accessibility Insights"],
          "exampleConfigFiles": [],
          "notes": "Apply accessibility tooling to ASP.NET or Blazor front-ends and review issues alongside functional testing.",
          "verification": "For web-facing apps, run the configured accessibility checks or tools against your main UI endpoints and confirm that blocking accessibility issues are addressed."
        }
      },
      {
        "id": "ai-drift-detection",
        "label": "AI Drift Detection",
        "description": "Run nightly or scheduled checks comparing AI-generated outputs against pinned baselines to detect model drift, prompt drift, or code changes affecting AI behavior. Attribute regressions to code changes vs model updates vs prompt changes.",
        "ciHints": {
          "github-actions": {
            "job": "nightly",
            "notes": "Use scheduled workflow (cron) to run AI drift detection nightly."
          }
        },
        "stack": {
          "exampleTools": ["Verify", "custom baseline tests"],
          "exampleConfigFiles": ["*.verified.txt", "ai-baselines/"],
          "notes": "Use Verify library or custom comparison tests to detect AI output drift. Run nightly to catch model-side changes that don't show up in code diffs.",
          "verification": "Run AI baseline tests and confirm outputs match pinned baselines."
        }
      },
      {
        "id": "ai-schema-enforcement",
        "label": "AI Output Schema Enforcement",
        "description": "Validate all AI-generated outputs against strict JSON schemas or type definitions at system boundaries. Reject invalid outputs early rather than letting malformed data propagate through the system.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Include AI output schema validation in CI test suite."
          }
        },
        "stack": {
          "exampleTools": [
            "System.Text.Json",
            "FluentValidation",
            "JsonSchema.Net"
          ],
          "exampleConfigFiles": ["*.schema.json", "Schemas/"],
          "notes": "Use strongly-typed DTOs with validation attributes or FluentValidation for AI outputs. Deserialize with strict settings that reject unknown properties.",
          "verification": "Review AI integration code and confirm outputs are validated against schemas."
        }
      },
      {
        "id": "ai-golden-tests",
        "label": "AI Golden Contract Tests",
        "description": "Validate AI tool-generated patches, configs, and code against exact expected formats. Test that AI outputs respect forbidden paths, file patterns, and format constraints through golden contract tests.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Include AI golden contract tests in CI test suite."
          }
        },
        "stack": {
          "exampleTools": ["xUnit", "Verify"],
          "exampleConfigFiles": ["TestData/", "*.verified.json"],
          "notes": "Use Verify for golden file testing of AI outputs. Ensure AI-generated code respects namespace conventions and doesn't modify protected files.",
          "verification": "Run golden tests and confirm AI outputs match verified snapshots."
        }
      },
      {
        "id": "ai-safety-checks",
        "label": "AI Adversarial & Safety Testing",
        "description": "Test AI integrations for prompt injection resistance, input sanitization, output filtering, and data exfiltration prevention. Include adversarial test cases that attempt to manipulate AI behavior.",
        "ciHints": {
          "github-actions": {
            "job": "security",
            "notes": "Run AI safety checks on main branch merges."
          }
        },
        "stack": {
          "exampleTools": ["xUnit", "custom security tests"],
          "exampleConfigFiles": ["Tests/AiSafety/"],
          "notes": "Test prompt injection resistance and output sanitization. Ensure AI outputs are escaped/validated before use in SQL queries, command execution, or HTML rendering.",
          "verification": "Run AI safety tests and confirm adversarial inputs are handled safely."
        }
      },
      {
        "id": "ai-provenance-tracking",
        "label": "AI Provenance & Audit Logging",
        "description": "Log AI provider, model version, prompt template version, parameters, and tool versions for all AI operations. Enable attribution of outputs to specific model+prompt combinations for debugging and compliance.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Check AI provenance logging implementation in CI."
          }
        },
        "stack": {
          "exampleTools": ["OpenTelemetry", "Serilog"],
          "exampleConfigFiles": ["AiProvenance.cs"],
          "notes": "Use structured logging to capture AI call provenance. Include model version, prompt hash, and parameters in log context.",
          "verification": "Review AI integration and confirm provenance logging is implemented."
        }
      },
      {
        "id": "agent-invariants",
        "label": "Autonomous Agent Invariants",
        "description": "Maintain INVARIANTS.md defining repository-wide rules that must always hold true, with machine-readable verification commands for autonomous agents.",
        "ciHints": {
          "github-actions": {
            "job": "ci",
            "notes": "Add invariant checks to existing CI job or create dedicated invariants job."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["INVARIANTS.md"],
          "notes": "Document invariants with verification commands like 'dotnet test', 'dotnet format --verify-no-changes', 'dotnet build' for autonomous validation.",
          "verification": "INVARIANTS.md exists with machine-readable verification commands.",
          "requiredFiles": ["INVARIANTS.md"]
        }
      }
    ],
    "optionalEnhancements": [
      {
        "id": "observability",
        "label": "Observability (Logging & Error Handling)",
        "description": "Standardize error handling and structured logging to make debugging and production monitoring easier.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": ["Serilog", "NLog"],
          "exampleConfigFiles": ["appsettings.json"],
          "notes": "Configure structured logging for your .NET services and ensure exceptions and key events are logged with useful context.",
          "verification": "Confirm that a structured logging library (such as Serilog or NLog) is configured with an agreed sink and format, and that the application logs meaningful context for errors and key events."
        }
      },
      {
        "id": "agent-phase-gates",
        "label": "Agent Phase Gates",
        "description": "Define phase transition requirements in phase-gates.md for autonomous agent workflows with clear pre-conditions and approval gates.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["phase-gates.md"],
          "notes": "Define phase gates with .NET-specific verification (dotnet test, coverage reports, NuGet package publishing) and approval workflows.",
          "verification": "phase-gates.md exists defining transition requirements.",
          "optionalFiles": ["phase-gates.md"]
        }
      },
      {
        "id": "agent-victory-gates",
        "label": "Agent Victory Gates",
        "description": "Document milestone completion criteria in victory-gates.md defining 'done' for releases and major deliverables with evidence requirements.",
        "ciHints": {
          "github-actions": {
            "job": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["victory-gates.md"],
          "notes": "Specify victory conditions for releases including .NET-specific requirements (NuGet publishing, deployment validation, documentation) and evidence collection.",
          "verification": "victory-gates.md exists with milestone criteria.",
          "optionalFiles": ["victory-gates.md"]
        }
      }
    ]
  }
}
