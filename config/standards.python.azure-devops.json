{
  "version": 4,
  "stack": "python",
  "stackLabel": "Python",
  "ciSystems": ["azure-devops"],
  "meta": {
    "defaultCoverageThreshold": 0.8,
    "coverageThresholdUnit": "ratio",
    "coverageThresholdDescription": "Expressed as a ratio (0-1), e.g., 0.8 = 80% coverage. Must be between 0 and 1.",
    "complexityChecks": {
      "enabledByDefault": true,
      "description": "When supported by the stack, run cyclomatic complexity or similar metrics in CI as a warning-only check initially."
    },
    "qualityGatePolicy": {
      "preferSoftFailOnLegacy": true,
      "description": "New quality checks should warn on existing code and fail CI only for violations introduced in new or changed code, to reduce friction on legacy codebases."
    },
    "migrationGuide": [
      {
        "step": 0,
        "title": "Foundation: Line Endings and Hook Entry Point",
        "description": "Configure .gitattributes for cross-platform line ending correctness and establish the canonical verify entrypoint before adding any checks. This prevents 'works locally, fails in CI' issues from day one.",
        "focusIds": [
          "gitattributes-eol",
          "canonical-verify",
          "hook-ci-parity",
          "config-authority"
        ],
        "notes": "Start here to avoid debugging cryptic CRLF failures later. Use .gitattributes as the authority for EOL (not .editorconfig). Run 'git add --renormalize .' after adding .gitattributes to fix existing files."
      },
      {
        "step": 1,
        "title": "Establish Local Safety Nets First",
        "description": "Add pre-commit hooks with secret scanning, formatting, and linting. Hooks should CHECK (not auto-fix) and scope to changed files only for speed.",
        "focusIds": [
          "pre-commit-hooks",
          "secret-scanning-precommit",
          "linting",
          "code-formatter"
        ],
        "notes": "Keep hooks fast by scoping to staged files. Use Husky as entry point calling lint-staged or pre-commit. Hooks should check, not fix, to keep developers aware of issues."
      },
      {
        "step": 2,
        "title": "Mirror Local Checks in CI with CRLF Detection",
        "description": "Introduce CI quality gates that mirror local hooks exactly. Add CRLF detection early in pipeline. Treat existing violations as warnings where possible.",
        "focusIds": [
          "crlf-detection",
          "ci-quality-gates",
          "linting",
          "code-formatter",
          "commit-linting"
        ],
        "notes": "CI must call the same verify scripts that hooks use. Add CRLF detection before other checks to fail fast on line ending issues. Use diff-based tools so only new violations break builds."
      },
      {
        "step": 3,
        "title": "Add Type Safety, Coverage, and Dependency Security",
        "description": "Enable type-checking, coverage thresholds, and dependency/vulnerability scanning with gradual enforcement.",
        "focusIds": [
          "type-checking",
          "unit-test-runner",
          "unit-test-reporter",
          "dependency-security",
          "dependency-update-automation"
        ],
        "notes": "Pin tool and runtime versions in CI and containers to avoid flaky differences across environments."
      },
      {
        "step": 4,
        "title": "Layer in Docs, Governance, and Recommended Checks",
        "description": "Add documentation standards, governance files, integration testing, performance baselines, complexity analysis, accessibility auditing, and (optionally) ML-specific practices for data-heavy Python repos.",
        "focusIds": [
          "documentation",
          "repository-governance",
          "integration-testing",
          "performance-baselining",
          "complexity-analysis",
          "accessibility-auditing"
        ],
        "notes": "Tackle recommended items in order of business value; backend-only repos can skip web-focused checks like accessibility."
      },
      {
        "step": 5,
        "title": "AI/ML Governance (If Applicable)",
        "description": "For repos using or building with generative AI, add drift detection, schema enforcement, golden contract tests, safety testing, and provenance tracking.",
        "focusIds": [
          "ai-drift-detection",
          "ai-schema-enforcement",
          "ai-golden-tests",
          "ai-safety-checks",
          "ai-provenance-tracking"
        ],
        "notes": "Skip this step if your repo has no AI/ML components. For AI-heavy repos: add nightly drift detection to catch model changes, enforce strict schemas at AI output boundaries, and log provenance for debugging 'why did AI do X?'"
      }
    ],
    "executorHints": {
      "description": "Advisory execution substrate hints. Bazel is the first supported executor; future monorepo executors may follow the same pattern.",
      "bazel": {
        "detectionRules": {
          "rootMarkers": ["MODULE.bazel", "WORKSPACE.bazel", "WORKSPACE"],
          "optionalMarkers": [".bazelrc", ".bazelversion"],
          "notes": "Detection uses repo-root markers only. Nested BUILD files do not trigger Bazel mode."
        },
        "optOut": {
          "description": "Set meta.executorHints.bazel.enabled = false in repo config to disable Bazel hints",
          "configPath": "meta.executorHints.bazel.enabled"
        },
        "targetConventions": {
          "description": "Recommended target naming (not assumed to exist). These are illustrative patterns; actual targets are repo-defined.",
          "lint": "//tools/lint:lint or bazel test //... with lint aspects",
          "format": "bazel run //tools/format:check",
          "test": "bazel test //...",
          "coverage": "bazel coverage //...",
          "build": "bazel build //..."
        },
        "ciContract": {
          "versionPinning": "Use .bazelversion file for Bazelisk",
          "configFlag": "--config=ci (define in .bazelrc)",
          "deterministicFlags": ["--nokeep_going", "--test_output=errors"],
          "remoteCache": "Optional; not required for CI"
        },
        "advisoryNotice": "bazelHints are suggestions, not required execution paths. Consumers should prefer stack-native commands unless explicitly adopting Bazel."
      }
    }
  },
  "checklist": {
    "core": [
      {
        "id": "gitattributes-eol",
        "label": "Git Attributes (Line Endings)",
        "description": "Enforce line endings at the Git layer using .gitattributes. Mark text files with appropriate EOL handling (eol=lf for shell scripts, eol=auto for most files) and binary files as binary to prevent corruption. This prevents 'works locally, fails in CI' issues caused by CRLF/LF mismatches.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection early in pipeline before other checks."
          }
        },
        "stack": {
          "exampleTools": ["git"],
          "exampleConfigFiles": [".gitattributes", ".editorconfig"],
          "notes": "Python files should use LF endings for cross-platform compatibility. Mark *.py as eol=lf in .gitattributes. Shebang scripts fail with CRLF.",
          "verification": "Run 'git ls-files --eol' and verify Python files use LF.",
          "requiredFiles": [".gitattributes"],
          "optionalFiles": [".editorconfig"],
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.py$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Verify no CRLF in Python files"
          }
        }
      },
      {
        "id": "crlf-detection",
        "label": "CRLF Detection in CI",
        "description": "Fail CI early for Linux-executed files containing CRLF line endings. Shell scripts, Python files, and other interpreted files fail silently or with cryptic errors when they contain \\r characters. Detect this before running deeper CI steps.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run CRLF detection as the first quality check before linting or testing."
          }
        },
        "stack": {
          "exampleTools": ["file", "grep"],
          "exampleConfigFiles": [],
          "notes": "Python shebang scripts fail with CRLF. Check all .py and .sh files for CRLF before running pytest or other Python tools.",
          "verification": "Run CRLF detection on Python and shell files.",
          "machineCheck": {
            "command": "git ls-files --eol | grep -E 'w/crlf.*\\.(py|sh)$' && exit 1 || exit 0",
            "expectExitCode": 0,
            "description": "Detect CRLF in Python/shell files"
          }
        }
      },
      {
        "id": "gitignore-and-dockerignore",
        "label": "Git and Docker Ignore Files",
        "description": "Maintain proper .gitignore and .dockerignore files to prevent committing secrets, build artifacts, or unnecessary files.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleConfigFiles": [".gitignore", ".dockerignore"],
          "notes": "Use the official github/gitignore Python template. Include **pycache**, .venv/, .pytest_cache, .env, and similar local-only files. .dockerignore must exclude .git, virtual environments, and caches.",
          "verification": ".gitignore must exist; .dockerignore is recommended when containerizing or using Docker workflows.",
          "requiredFiles": [".gitignore"],
          "optionalFiles": [".dockerignore"]
        }
      },
      {
        "id": "linting",
        "label": "Linting",
        "description": "Run static code linting to enforce consistency and catch common issues early.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["ruff", "flake8"],
          "exampleConfigFiles": ["pyproject.toml", ".flake8", "ruff.toml"],
          "notes": "Configure a primary linter (such as ruff) and keep rules focused on catching real issues without overwhelming developers.",
          "verification": "pyproject.toml (or ruff.toml / .flake8 / setup.cfg) signals that linting tools are configured for the repository.",
          "anyOfFiles": [
            "pyproject.toml",
            "ruff.toml",
            ".flake8",
            "setup.cfg",
            "tox.ini"
          ],
          "bazelHints": {
            "commands": [
              "bazel test //...:ruff_test",
              "bazel run //tools/lint:ruff -- check ."
            ],
            "notes": "Example only; actual targets are repo-defined. Use rules_python with ruff wrapped as py_test or run target."
          }
        }
      },
      {
        "id": "unit-test-runner",
        "label": "Unit Test Runner",
        "description": "Provide a deterministic unit test framework with a single command to run all tests.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["pytest"],
          "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
          "notes": "Organize unit tests under a tests/ directory and avoid real network or database calls in this layer.",
          "verification": "Test framework configuration is present; tests/ directory or pytest configuration exists.",
          "optionalFiles": ["pytest.ini", "pyproject.toml", "tests/"],
          "bazelHints": {
            "commands": ["bazel test //..."],
            "notes": "Example only; actual targets are repo-defined. Use rules_python py_test for pytest-based tests."
          }
        }
      },
      {
        "id": "containerization",
        "label": "Containerization (Docker / Docker Compose)",
        "description": "Provide a Dockerfile and, if applicable, a docker-compose file for local dev and CI parity.",
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["Dockerfile", "docker-compose.yml"],
          "notes": "Choose a slim Python base image, pin the version, and clearly document how to start the service in a container.",
          "verification": "Dockerfile must be present; docker-compose.yml is optional and indicates orchestration usage.",
          "requiredFiles": ["Dockerfile"],
          "optionalFiles": ["docker-compose.yml"]
        }
      },
      {
        "id": "semantic-versioning",
        "label": "Semantic Versioning",
        "description": "Use MAJOR.MINOR.PATCH versioning with clear rules and automated changelog generation based on commit history. Maintain a single canonical version source (for example, package.json or VERSION) that all release artifacts use.",
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          }
        },
        "stack": {
          "exampleTools": ["bumpversion", "setuptools_scm", "towncrier"],
          "exampleConfigFiles": ["pyproject.toml", "setup.cfg", "CHANGELOG.md"],
          "notes": "Automate version bumping and changelog generation using setuptools_scm (git-tag based) or bumpversion with towncrier for changelog fragments. Keep pyproject.toml (or VERSION) as the single canonical version source, and have CI publish GitHub/PyPI/Docker artifacts from that same version.",
          "verification": "Check that the canonical version in pyproject.toml or VERSION follows SemVer and verify that the configured tool (for example, setuptools_scm or bumpversion) computes or bumps the version and generates changelog entries from commit history or fragments.",
          "requiredFiles": ["pyproject.toml"],
          "optionalFiles": ["VERSION", "CHANGELOG.md"],
          "requiredScripts": ["release"]
        }
      },
      {
        "id": "unified-release-workflow",
        "label": "Unified Release Workflow",
        "description": "Use a single CI release pipeline that publishes all artifacts (GitHub releases, packages, containers) from the same canonical version source.",
        "ciHints": {
          "azure-devops": {
            "stage": "release"
          }
        },
        "stack": {
          "exampleTools": ["setuptools_scm", "twine", "build", "docker buildx"],
          "exampleConfigFiles": [
            ".github/workflows/release.yml",
            "azure-pipelines.yml"
          ],
          "notes": "Use a single release pipeline to publish PyPI packages, GitHub releases, and Docker images from the canonical version source (pyproject.toml or VERSION).",
          "verification": "Trigger the release pipeline and confirm all artifacts share the same version number and tag.",
          "requiredScripts": ["release"],
          "optionalFiles": ["CHANGELOG.md", "VERSION"]
        }
      },
      {
        "id": "release-hook-bypass",
        "label": "Release Hook Bypass",
        "description": "Release automation must bypass local developer hooks (HUSKY=0, --no-verify) and rely solely on CI gates for validation. This ensures idempotent, reproducible releases that don't fail due to hook environment differences.",
        "ciHints": {
          "azure-devops": {
            "stage": "release",
            "notes": "Set HUSKY=0 or equivalent in release pipeline to disable hooks."
          }
        },
        "stack": {
          "exampleTools": ["semantic-release", "bumpversion"],
          "exampleConfigFiles": [".github/workflows/release.yml"],
          "notes": "Set PRE_COMMIT_ALLOW_NO_CONFIG=1 or SKIP=all to bypass pre-commit hooks in release automation. CI gates already validated.",
          "verification": "Check release workflow for pre-commit bypass."
        }
      },
      {
        "id": "commit-linting",
        "label": "Commit Linting",
        "description": "Enforce structured commit messages such as Conventional Commits via commit-msg hooks and CI. This is required for deterministic versioning and changelog generation.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["commitizen"],
          "exampleConfigFiles": [".cz.toml", "pyproject.toml"],
          "notes": "Standardize Conventional Commits using commitizen or commitlint with commit-msg hooks plus CI so changelog generation is deterministic.",
          "verification": "Use the configured commit helper or hooks to create a test commit and confirm that non-conforming messages are rejected locally and in CI.",
          "anyOfFiles": [
            ".cz.toml",
            "commitlint.config.js",
            "commitlint.config.cjs",
            "commitlint.config.mjs",
            "commitlint.config.json"
          ],
          "requiredScripts": ["commitlint"]
        }
      },
      {
        "id": "unit-test-reporter",
        "label": "Unit Test Reporter / Coverage",
        "description": "Generate readable unit test and coverage reports and enforce a minimum coverage threshold (around 80%) for new or changed code.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["pytest", "pytest-cov", "coverage.py"],
          "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
          "notes": "Configure coverage reporting for your test suite and surface summary metrics in CI.",
          "verification": "Run the unit tests with coverage (for example, pytest with pytest-cov) and confirm that coverage reports are generated and referenced in CI to enforce or track thresholds.",
          "bazelHints": {
            "commands": ["bazel coverage //..."],
            "notes": "Use rules_python py_test with coverage instrumentation. Combine with --combined_report=lcov."
          }
        }
      },
      {
        "id": "ci-quality-gates",
        "label": "CI Quality Gates",
        "description": "Single CI pipeline that runs linting, formatting, type checking, tests, coverage, build, and containerization.",
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [".github/workflows/*", "azure-pipelines.yml"],
          "notes": "Ensure CI runs linting, type checking (if used), tests, and packaging or container checks for Python services before merging.",
          "verification": "Open the CI configuration and verify there is a job or stage that runs linting, type checking (if used), tests, and any packaging or container checks before merging to main.",
          "bazelHints": {
            "commands": ["bazel build //...", "bazel test //..."],
            "notes": "Bazel py_binary and py_test targets replace traditional Python tooling."
          }
        }
      },
      {
        "id": "code-formatter",
        "label": "Code Formatter",
        "description": "Automatic code formatting to maintain a consistent style across all contributors.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["black"],
          "exampleConfigFiles": ["pyproject.toml"],
          "notes": "Use black (or an equivalent opinionated formatter) and treat its output as the single source of truth for code style.",
          "verification": "Run the configured formatter (for example, `black .` or `black --check .`) and confirm it reports clean formatting on committed code and auto-fixes as expected locally.",
          "bazelHints": {
            "commands": ["bazel run //tools/format:black -- --check ."],
            "notes": "Wrap black as a py_binary run target for format checking."
          }
        }
      },
      {
        "id": "pre-commit-hooks",
        "label": "Pre-Commit Hooks",
        "description": "Use git hooks to run linting, formatting, and commit linting before changes are committed. Hooks should CHECK by default (not auto-fix), be fast, and scope to changed files only. Use a single entry hook mechanism (e.g., Husky as entry point calling pre-commit or lint-staged).",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Hooks and CI must invoke identical verification commands. Use npm run verify or equivalent."
          }
        },
        "stack": {
          "exampleTools": ["pre-commit"],
          "exampleConfigFiles": [".pre-commit-config.yaml"],
          "notes": "Use pre-commit framework as both entry and executor. Pin hook versions in .pre-commit-config.yaml for determinism. Hooks should run checks (ruff check, black --check) not auto-fix. Run pre-commit install to set up hooks.",
          "verification": "Inspect .pre-commit-config.yaml and confirm hooks use check/verify flags, not auto-fix."
        }
      },
      {
        "id": "hook-ci-parity",
        "label": "Hook/CI Parity",
        "description": "Local hooks and CI must invoke identical verification commands to prevent 'works locally, fails in CI' issues. Use a single canonical verify entrypoint (e.g., npm run verify) that both hooks and CI call.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the same verify script that hooks use locally."
          }
        },
        "stack": {
          "exampleTools": ["make", "tox", "nox"],
          "exampleConfigFiles": ["Makefile", "tox.ini", "noxfile.py"],
          "notes": "Define a verify target (make verify, tox -e lint, or nox -s lint) that both pre-commit and CI invoke. Pin tool versions in pyproject.toml.",
          "verification": "Compare hook commands with CI commands and confirm they invoke the same targets."
        }
      },
      {
        "id": "secret-scanning-precommit",
        "label": "Pre-commit Secret Scanning",
        "description": "Scan staged diffs for credentials, API keys, and secrets before they reach the remote repository. Catch secrets at commit time rather than after they're pushed.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Also run secret scanning in CI as a safety net for commits that bypassed hooks."
          }
        },
        "stack": {
          "exampleTools": ["detect-secrets", "gitleaks"],
          "exampleConfigFiles": [
            ".pre-commit-config.yaml",
            ".secrets.baseline"
          ],
          "notes": "Add detect-secrets or gitleaks to .pre-commit-config.yaml. Use detect-secrets audit to manage baselines.",
          "verification": "Run 'detect-secrets scan' or 'gitleaks protect' and verify scanning works."
        }
      },
      {
        "id": "type-checking",
        "label": "Type Checking",
        "description": "Use static type checking to catch errors before runtime and enforce strictness on new code. For JS/TS stacks, require a TypeScript-first policy with strict mode and a CI typecheck step; allow JSDoc/checkJs migration for legacy JS.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["mypy"],
          "exampleConfigFiles": ["mypy.ini", "pyproject.toml"],
          "notes": "Adopt gradual typing with type hints and mypy, focusing first on critical modules and new code paths.",
          "verification": "pyproject.toml (or mypy.ini) signals that mypy configuration is available for the repository.",
          "requiredFiles": ["pyproject.toml"],
          "optionalFiles": ["mypy.ini"],
          "requiredScripts": ["typecheck"],
          "bazelHints": {
            "commands": [
              "bazel test //...:mypy_test",
              "bazel run //tools/typecheck:mypy"
            ],
            "notes": "Example only; actual targets are repo-defined. Wrap mypy as a py_test or run target."
          }
        }
      },
      {
        "id": "dependency-security",
        "label": "Dependency Management & Vulnerability Scanning",
        "description": "Lock dependencies and scan regularly for known vulnerabilities; fail CI on newly introduced high-severity issues.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["pip-audit", "safety"],
          "exampleConfigFiles": [
            "requirements.txt",
            "Pipfile.lock",
            "poetry.lock"
          ],
          "notes": "Pin dependency versions and routinely scan for vulnerabilities, prioritizing fixes for critical and high-severity issues.",
          "verification": "Dependency lockfile is present; security scanning is configured in CI or project tooling.",
          "optionalFiles": ["requirements.txt", "Pipfile.lock", "poetry.lock"]
        }
      },
      {
        "id": "deterministic-builds",
        "label": "Deterministic & Hermetic Builds",
        "description": "Ensure builds are reproducible by pinning dependencies, base images, and tool/runtime versions. Avoid network/time variance and fail when lockfiles drift.",
        "ciHints": {
          "azure-devops": {
            "stage": "build"
          }
        },
        "stack": {
          "exampleTools": ["pip-tools", "poetry", "uv"],
          "exampleConfigFiles": [
            "requirements.txt",
            "poetry.lock",
            "Pipfile.lock"
          ],
          "notes": "Use pinned lockfiles (requirements.txt or poetry.lock) and pin Python version (.python-version or tool-versions). Avoid non-deterministic installs in CI.",
          "verification": "Lockfile is present and CI installs with pinned versions only. Python runtime is pinned.",
          "anyOfFiles": ["requirements.txt", "poetry.lock", "Pipfile.lock"],
          "optionalFiles": [".python-version", ".tool-versions"]
        }
      },
      {
        "id": "provenance-security",
        "label": "Provenance & Security Metadata",
        "description": "Produce SBOMs or provenance metadata, enable secret/code scanning, and sign tags or commits for critical repos.",
        "ciHints": {
          "azure-devops": {
            "stage": "security"
          }
        },
        "stack": {
          "exampleTools": [
            "cyclonedx-python",
            "syft",
            "codeql",
            "gitleaks",
            "cosign"
          ],
          "exampleConfigFiles": [
            ".github/workflows/codeql.yml",
            ".github/workflows/provenance.yml"
          ],
          "notes": "Generate SBOM/provenance for PyPI and container artifacts, enable secret scanning, and sign tags/commits for critical repos.",
          "verification": "SBOM/provenance artifacts are published alongside releases, and CI runs secret/code scanning.",
          "optionalFiles": ["SECURITY.md", ".github/workflows/codeql.yml"]
        }
      },
      {
        "id": "ci-templates-automation",
        "label": "CI Templates & Automation",
        "description": "Adopt standard CI templates and config samples to scale across repositories, minimizing bespoke pipeline logic.",
        "ciHints": {
          "azure-devops": {
            "stage": "ci"
          }
        },
        "stack": {
          "exampleTools": [
            "GitHub Actions reusable workflows",
            "Azure DevOps templates"
          ],
          "exampleConfigFiles": [
            ".github/workflows/ci.yml",
            "azure-pipelines.yml"
          ],
          "notes": "Use shared CI templates for lint/test/typecheck/release stages to standardize across Python repos.",
          "verification": "CI pipeline references a shared template or reusable workflow and follows the standard job naming.",
          "anyOfFiles": [".github/workflows/ci.yml", "azure-pipelines.yml"],
          "requiredScripts": ["ci"]
        }
      },
      {
        "id": "runtime-version",
        "label": "Runtime Version Specification",
        "description": "Specify required runtime/engine versions in package manifests to ensure environment stability and prevent version-related issues across development teams.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            "pyproject.toml",
            "setup.py",
            ".python-version"
          ],
          "notes": "Specify python_requires in pyproject.toml (e.g., requires-python = \">=3.9\") or setup.py (e.g., python_requires='>=3.9'). Consider adding .python-version for pyenv users to automatically switch to the correct Python version.",
          "verification": "pyproject.toml or setup.py must specify python_requires; .python-version is recommended for local development.",
          "requiredFiles": ["pyproject.toml"],
          "optionalFiles": [".python-version"]
        }
      },
      {
        "id": "documentation",
        "label": "Documentation Standards",
        "description": "Maintain a comprehensive README and, where applicable, auto-generated API docs to support onboarding and maintainability.",
        "ciHints": {
          "azure-devops": {
            "stage": "docs"
          }
        },
        "stack": {
          "exampleTools": ["Sphinx", "MkDocs"],
          "exampleConfigFiles": ["README.md", "docs/"],
          "notes": "Ensure README explains environment setup and core commands, and generate API docs from docstrings where appropriate.",
          "verification": "README.md is present in the repository root; docs/ directory or documentation tooling configuration exists if applicable.",
          "requiredFiles": ["README.md"],
          "optionalFiles": ["docs/", "mkdocs.yml"]
        }
      },
      {
        "id": "repository-governance",
        "label": "Repository Governance",
        "description": "Include standard governance files (LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md), branch protection rules, and review standards to define legal, ethical, and workflow expectations.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            "LICENSE",
            "CODE_OF_CONDUCT.md",
            "CONTRIBUTING.md"
          ],
          "notes": "Spell out contributor responsibilities for tests, documentation, and review so expectations are clear for Python-focused teams.",
          "verification": "LICENSE file is present in the repository root; CODE_OF_CONDUCT.md and CONTRIBUTING.md are present for contribution guidance.",
          "requiredFiles": ["LICENSE"],
          "optionalFiles": ["CODE_OF_CONDUCT.md", "CONTRIBUTING.md"]
        }
      },
      {
        "id": "canonical-verify",
        "label": "Canonical Verify Entrypoint",
        "description": "Provide one canonical 'verify' command per repository/stack that all stages call with appropriate flags. This prevents duplication, drift, and ensures consistency between local development and CI.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should call the canonical verify command, not duplicate check logic."
          }
        },
        "stack": {
          "exampleTools": ["make", "tox", "nox"],
          "exampleConfigFiles": ["Makefile", "tox.ini", "noxfile.py"],
          "notes": "Define 'make verify' or 'tox -e verify' that runs ruff, black --check, mypy, and pytest. All stages use this entrypoint.",
          "verification": "Makefile or tox.ini contains a 'verify' target/environment."
        }
      },
      {
        "id": "config-authority",
        "label": "Config File Authority Rules",
        "description": "Each configuration rule must live in exactly one authoritative config file. Avoid duplication across .editorconfig, linter configs, and CI definitions. Document which file is authoritative for each concern.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Ensure CI reads from authoritative configs, not duplicated settings."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": [
            ".gitattributes",
            "pyproject.toml",
            ".editorconfig"
          ],
          "notes": "Authority mapping: .gitattributes for EOL, pyproject.toml for all tool configs (ruff, black, mypy, pytest). Avoid separate tool configs (.flake8, setup.cfg) when pyproject.toml can hold them.",
          "verification": "Review configs and confirm pyproject.toml is the single source for tool settings."
        }
      },
      {
        "id": "explicit-skip-paths",
        "label": "Explicit Skip Paths",
        "description": "Encode path exclusions and skip rules deterministically in config files, not through ad-hoc human judgment. Make it clear which paths are excluded from checks and why.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI should read skip paths from config files, not hardcode them in pipeline."
          }
        },
        "stack": {
          "exampleTools": ["ruff", "black", "mypy"],
          "exampleConfigFiles": ["pyproject.toml"],
          "notes": "Define exclude patterns in pyproject.toml [tool.ruff], [tool.black], [tool.mypy] sections. Document why each path is excluded. Avoid runtime --exclude flags.",
          "verification": "Review pyproject.toml and confirm all exclusions are defined there, not in scripts."
        }
      }
    ],
    "recommended": [
      {
        "id": "dependency-update-automation",
        "label": "Dependency Update Automation",
        "description": "Automate dependency updates using Renovate or Dependabot to keep dependencies current and reduce security exposure window.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          }
        },
        "stack": {
          "exampleTools": ["renovate", "dependabot"],
          "exampleConfigFiles": ["renovate.json", ".github/dependabot.yml"],
          "notes": "Renovate supports pyproject.toml, requirements.txt, Pipfile, poetry.lock. For AzDO: self-hosted Renovate or schedule-triggered pipeline.",
          "verification": "Check for renovate.json OR .github/dependabot.yml. Verify Python dependency PRs.",
          "anyOfFiles": [
            "renovate.json",
            ".renovaterc.json",
            ".github/dependabot.yml"
          ],
          "pinningNotes": "Use requirements.txt with pinned versions or poetry.lock for deterministic installs."
        }
      },
      {
        "id": "dependency-architecture-rules",
        "label": "Dependency Architecture Rules",
        "description": "Enforce module boundaries and import constraints to prevent architectural drift and unwanted coupling.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "CI hints are suggested mappings; adjust to your pipeline topology."
          }
        },
        "stack": {
          "exampleTools": ["import-linter", "pydeps"],
          "exampleConfigFiles": ["pyproject.toml", ".importlinter"],
          "notes": "Configure [tool.importlinter] in pyproject.toml OR use standalone .importlinter file. pydeps is visualization-only.",
          "verification": "Run 'lint-imports' successfully. Config must exist in pyproject.toml [tool.importlinter] section OR .importlinter file.",
          "optionalFiles": ["pyproject.toml", ".importlinter"]
        }
      },
      {
        "id": "integration-testing",
        "label": "Integration Testing",
        "description": "Test how components interact with each other and external systems, running after unit tests with more relaxed coverage thresholds.",
        "ciHints": {
          "azure-devops": {
            "stage": "test"
          }
        },
        "stack": {
          "exampleTools": ["pytest"],
          "exampleConfigFiles": ["tests/integration/"],
          "notes": "Separate integration tests from unit tests, using fixtures to handle databases, services, or other external systems.",
          "verification": "Confirm there is a separate integration or API test suite (for example, a dedicated tests/integration directory) and run it to verify interactions with databases, services, or external systems."
        }
      },
      {
        "id": "performance-baselining",
        "label": "Performance Baselines",
        "description": "Establish performance baselines and monitor for regressions using lightweight benchmarks or audits in CI.",
        "ciHints": {
          "azure-devops": {
            "stage": "performance"
          }
        },
        "stack": {
          "exampleTools": ["pytest-benchmark", "cProfile"],
          "exampleConfigFiles": ["pytest.ini", "pyproject.toml"],
          "notes": "Use simple benchmarks or profiling runs to characterize bottlenecks and watch for regressions in critical workflows.",
          "verification": "Identify and run the configured performance checks or benchmarks (for example, pytest-benchmark or cProfile-based scripts) and confirm that their results are recorded and compared over time."
        }
      },
      {
        "id": "complexity-analysis",
        "label": "Complexity Analysis",
        "description": "Measure cyclomatic complexity or similar metrics to keep code maintainable, starting as a warning-only check.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["radon"],
          "exampleConfigFiles": ["radon.cfg"],
          "notes": "Use radon or similar tools to track complexity of Python functions and keep new code within acceptable limits.",
          "verification": "Run the configured complexity tool (for example, radon) on the codebase and review the report to ensure new or heavily changed functions are not excessively complex."
        }
      },
      {
        "id": "accessibility-auditing",
        "label": "Accessibility Auditing",
        "description": "Run accessibility checks on web-facing components to detect critical issues and improve inclusive UX.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality"
          }
        },
        "stack": {
          "exampleTools": ["pa11y"],
          "exampleConfigFiles": [],
          "notes": "Use headless browser-based tools to scan Python-backed web UIs for accessibility issues on high-traffic routes.",
          "verification": "For Python-backed web UIs, run the configured accessibility tooling (for example, pa11y or axe via a headless browser) against key routes and verify that critical issues are fixed or tracked."
        }
      },
      {
        "id": "ai-drift-detection",
        "label": "AI Drift Detection",
        "description": "Run nightly or scheduled checks comparing AI-generated outputs against pinned baselines to detect model drift, prompt drift, or code changes affecting AI behavior. Attribute regressions to code changes vs model updates vs prompt changes.",
        "ciHints": {
          "azure-devops": {
            "stage": "nightly",
            "notes": "Run AI drift detection in a scheduled nightly pipeline separate from main CI."
          }
        },
        "stack": {
          "exampleTools": ["pytest", "deepdiff", "great_expectations"],
          "exampleConfigFiles": ["tests/ai_baselines/", "pytest.ini"],
          "notes": "Create golden output tests for AI-generated content. Use deepdiff for structured comparison. For ML models, also track metrics drift (accuracy, latency) not just output drift.",
          "verification": "Run AI baseline tests nightly and confirm outputs match or drift is documented."
        }
      },
      {
        "id": "ai-schema-enforcement",
        "label": "AI Output Schema Enforcement",
        "description": "Validate all AI-generated outputs against strict JSON schemas or type definitions at system boundaries. Reject invalid outputs early rather than letting malformed data propagate through the system.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run schema validation tests as part of quality gates."
          }
        },
        "stack": {
          "exampleTools": ["pydantic", "jsonschema", "marshmallow"],
          "exampleConfigFiles": ["schemas/", "models.py"],
          "notes": "Use Pydantic models for AI output validation. Enable strict mode to reject extra fields. Define clear schemas at system boundaries where AI outputs enter the codebase.",
          "verification": "Review AI integration code and confirm Pydantic or equivalent validation is in place."
        }
      },
      {
        "id": "ai-golden-tests",
        "label": "AI Golden Contract Tests",
        "description": "Validate AI tool-generated patches, configs, and code against exact expected formats. Test that AI outputs respect forbidden paths, file patterns, and format constraints through golden contract tests.",
        "ciHints": {
          "azure-devops": {
            "stage": "test",
            "notes": "Run AI golden tests as part of the test stage."
          }
        },
        "stack": {
          "exampleTools": ["pytest", "syrupy"],
          "exampleConfigFiles": ["tests/fixtures/", "__snapshots__/"],
          "notes": "Use pytest with syrupy for snapshot testing AI outputs. Test that generated code follows project conventions and respects forbidden paths.",
          "verification": "Run snapshot tests and confirm AI outputs match golden fixtures."
        }
      },
      {
        "id": "ai-safety-checks",
        "label": "AI Adversarial & Safety Testing",
        "description": "Test AI integrations for prompt injection resistance, input sanitization, output filtering, and data exfiltration prevention. Include adversarial test cases that attempt to manipulate AI behavior.",
        "ciHints": {
          "azure-devops": {
            "stage": "security",
            "notes": "Run AI safety tests as part of security stage on main branch."
          }
        },
        "stack": {
          "exampleTools": ["pytest", "hypothesis"],
          "exampleConfigFiles": ["tests/ai_safety/"],
          "notes": "Use hypothesis for property-based testing of AI input handling. Test prompt injection, output sanitization, and data boundary enforcement.",
          "verification": "Run AI safety tests including adversarial cases."
        }
      },
      {
        "id": "ai-provenance-tracking",
        "label": "AI Provenance & Audit Logging",
        "description": "Log AI provider, model version, prompt template version, parameters, and tool versions for all AI operations. Enable attribution of outputs to specific model+prompt combinations for debugging and compliance.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Verify AI provenance logging is implemented in quality checks."
          }
        },
        "stack": {
          "exampleTools": ["structlog", "OpenTelemetry", "MLflow"],
          "exampleConfigFiles": ["ai/provenance.py"],
          "notes": "Log AI provenance using structlog or MLflow tracking. For ML models, also track training data version and model artifact hash.",
          "verification": "Review AI integration and confirm provenance is tracked."
        }
      },
      {
        "id": "agent-invariants",
        "label": "Autonomous Agent Invariants",
        "description": "Maintain INVARIANTS.md defining repository-wide rules that must always hold true, with machine-readable verification commands for autonomous agents.",
        "ciHints": {
          "azure-devops": {
            "stage": "quality",
            "notes": "Run invariant verification commands in a dedicated quality stage."
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["INVARIANTS.md"],
          "notes": "List invariants with commands like 'pytest', 'ruff check', 'mypy' that agents can execute to verify repository state.",
          "verification": "INVARIANTS.md exists with machine-readable verification commands.",
          "requiredFiles": ["INVARIANTS.md"]
        }
      }
    ],
    "optionalEnhancements": [
      {
        "id": "observability",
        "label": "Observability (Logging & Error Handling)",
        "description": "Standardize error handling and structured logging to make debugging and production monitoring easier.",
        "ciHints": {
          "azure-devops": {
            "stage": "observability"
          }
        },
        "stack": {
          "exampleTools": ["structlog", "loguru"],
          "exampleConfigFiles": [
            "logging configuration files",
            "pyproject.toml"
          ],
          "notes": "Use structured logging for Python services and ensure critical paths record enough context to debug issues after the fact.",
          "verification": "Confirm that a structured logging setup (such as structlog or configured logging with JSON formatting) is in place and that critical paths log enough information to debug failures in production."
        }
      },
      {
        "id": "agent-phase-gates",
        "label": "Agent Phase Gates",
        "description": "Define phase transition requirements in phase-gates.md for autonomous agent workflows with clear pre-conditions and approval gates.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["phase-gates.md"],
          "notes": "Specify phase transitions with Python-specific checks (pytest results, wheel/sdist builds, PyPI publication) and approval processes.",
          "verification": "phase-gates.md exists defining transition requirements.",
          "optionalFiles": ["phase-gates.md"]
        }
      },
      {
        "id": "agent-victory-gates",
        "label": "Agent Victory Gates",
        "description": "Document milestone completion criteria in victory-gates.md defining 'done' for releases and major deliverables with evidence requirements.",
        "ciHints": {
          "azure-devops": {
            "stage": "governance"
          }
        },
        "stack": {
          "exampleTools": [],
          "exampleConfigFiles": ["victory-gates.md"],
          "notes": "Document release readiness gates with Python-specific criteria (PyPI publishing, wheel distribution, dependency compatibility) and proof artifacts.",
          "verification": "victory-gates.md exists with milestone criteria.",
          "optionalFiles": ["victory-gates.md"]
        }
      }
    ]
  }
}
